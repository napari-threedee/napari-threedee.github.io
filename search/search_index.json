{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#overview","title":"Overview","text":"<p>napari-threedee is a collection of tools for exploring, manipulating, and annotating your data in 3D. </p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p><code>napari-threedee</code> is a <code>napari</code> plugin and thus requires <code>napari</code> to work. You can see the <code>napari</code> documentation for  napari installation instructions. After you  have installed <code>napari</code>, you can install <code>napari-threedee</code> using the package manager of your choice using the commands  below.</p> pipconda <pre><code>pip install napari-threedee\n</code></pre> <pre><code>conda install -c conda-forge napari-threedee\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#users","title":"Users","text":"<p>Do you have rich 3D (or more!) data that you want to explore and annotate? <code>napari-threedee</code> comes with a collection  of plugins for just that. Please see our Getting started for users guide to get going.</p>"},{"location":"#developers","title":"Developers","text":"<p>Are you developing an image processing workflow that requires exploration or annotation of multidimensional data?  <code>napari-threedee</code> has a collection of composable compoents for adding 3D interactivity to your workflow! To get  started, see our Getting started for developers guide.</p>"},{"location":"API/geometry_utilities/","title":"Geometry utilities","text":""},{"location":"API/geometry_utilities/#geometry-utilities","title":"Geometry utilities","text":""},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry","title":"<code>napari_threedee.utils.geometry</code>","text":""},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.signed_angle_between_vectors","title":"<code>signed_angle_between_vectors(vector_0, vector_1, rotation_axis: np.ndarray) -&gt; float</code>","text":"<p>Returns the angle in radians between vectors 'v1' and 'v2'.</p> PARAMETER DESCRIPTION <code>vector_0</code> <p>The vector to start the rotation at.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>vector_1</code> <p>The vector the rotation ends at.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>rotation_axis</code> <p>The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1.</p> <p> TYPE: <code>np.ndarray</code> </p> RETURNS DESCRIPTION <code>angle</code> <p>The signed angle of rotation in radians.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/napari_threedee/utils/geometry.py</code> <pre><code>def signed_angle_between_vectors(vector_0, vector_1,\n                                 rotation_axis: np.ndarray) -&gt; float:\n\"\"\" Returns the angle in radians between vectors 'v1' and 'v2'.\n\n    Parameters\n    ----------\n    vector_0 : np.ndarray\n        The vector to start the rotation at.\n    vector_1 : np.ndarray\n        The vector the rotation ends at.\n    rotation_axis : np.ndarray\n        The axis around which the rotation is occuring.\n        Must be orthogonal to vector_0 and vector_1.\n\n    Returns\n    -------\n    angle : float\n        The signed angle of rotation in radians.\n    \"\"\"\n    unit_vector_0 = vector_0 / np.linalg.norm(vector_0)\n    unit_vector_1 = vector_1 / np.linalg.norm(vector_1)\n\n    unsigned_angle = np.arccos(np.clip(np.dot(unit_vector_0, unit_vector_1), -1.0, 1.0))\n\n    v3 = np.cross(unit_vector_0, unit_vector_1)\n\n    angle_sign = -1 if np.dot(v3, rotation_axis) &lt; 0 else 1\n\n    return angle_sign * unsigned_angle\n</code></pre>"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.rotation_matrix_around_vector_3d","title":"<code>rotation_matrix_around_vector_3d(angle: float, vector: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Create the rotation matrix for a specified angle of rotation around a vector.</p> PARAMETER DESCRIPTION <code>angle</code> <p>The signed angle of rotation in radians.</p> <p> TYPE: <code>float</code> </p> <p>vector : np.ndarray     The vector around which to perform the rotation.</p> RETURNS DESCRIPTION <code>rotation_matrix</code> <p>(3, 3) rotation matrix for the specified rotation.</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>src/napari_threedee/utils/geometry.py</code> <pre><code>def rotation_matrix_around_vector_3d(angle: float, vector: np.ndarray) -&gt; np.ndarray:\n\"\"\"Create the rotation matrix for a specified angle of rotation around a vector.\n\n    Parameters\n    ----------\n    angle : float\n        The signed angle of rotation in radians.\n\n    vector : np.ndarray\n        The vector around which to perform the rotation.\n\n    Returns\n    -------\n    rotation_matrix : np.ndarray\n        (3, 3) rotation matrix for the specified rotation.\n    \"\"\"\n    vector_u = vector / np.linalg.norm(vector)\n    u_0 = vector_u[0]\n    u_1 = vector_u[1]\n    u_2 = vector_u[2]\n\n    cos_term = 1 - np.cos(angle)\n    sine_term = np.sin(angle)\n\n    rotation_matrix = np.zeros((3, 3))\n    rotation_matrix[0, 0] = np.cos(angle) + (u_0 ** 2) * cos_term\n    rotation_matrix[0, 1] = (u_0 * u_1 * cos_term) - u_2 * sine_term\n    rotation_matrix[0, 2] = (u_0 * u_2 * cos_term) + u_1 * sine_term\n\n    rotation_matrix[1, 0] = (u_1 * u_0 * cos_term) + u_2 * sine_term\n    rotation_matrix[1, 1] = np.cos(angle) + (u_1 ** 2) * cos_term\n    rotation_matrix[1, 2] = (u_1 * u_2 * cos_term) - u_0 * sine_term\n\n    rotation_matrix[2, 0] = (u_0 * u_2 * cos_term) - u_1 * sine_term\n    rotation_matrix[2, 1] = u_1 * u_2 * cos_term + u_0 * sine_term\n    rotation_matrix[2, 2] = np.cos(angle) + (u_2 ** 2) * cos_term\n\n    return rotation_matrix\n</code></pre>"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.point_in_bounding_box","title":"<code>point_in_bounding_box(point: np.ndarray, bounding_box: np.ndarray) -&gt; bool</code>","text":"<p>Determine whether an nD point is inside an nD bounding box.</p> PARAMETER DESCRIPTION <code>point</code> <p>(n,) array containing nD point coordinates to check.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>bounding_box</code> <p>(2, n) array containing the min and max of the nD bounding box. As returned by <code>Layer._extent_data</code>.</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>src/napari_threedee/utils/geometry.py</code> <pre><code>def point_in_bounding_box(point: np.ndarray, bounding_box: np.ndarray) -&gt; bool:\n\"\"\"Determine whether an nD point is inside an nD bounding box.\n    Parameters\n    ----------\n    point : np.ndarray\n        (n,) array containing nD point coordinates to check.\n    bounding_box : np.ndarray\n        (2, n) array containing the min and max of the nD bounding box.\n        As returned by `Layer._extent_data`.\n    \"\"\"\n    if np.all(point &gt; bounding_box[0]) and np.all(point &lt; bounding_box[1]):\n        return True\n    return False\n</code></pre>"},{"location":"API/napari_utilities/","title":"napari utilities","text":""},{"location":"API/napari_utilities/#napari-utilities","title":"napari utilities","text":""},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils","title":"<code>napari_threedee.utils.napari_utils</code>","text":""},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_napari_visual","title":"<code>get_napari_visual(viewer, layer)</code>","text":"<p>Get the visual class for a given layer</p> PARAMETER DESCRIPTION <code>viewer</code> <p>The napari viewer object</p> <p> </p> <code>layer</code> <p>The napari layer object for which to find the visual.</p> <p> </p> RETURNS DESCRIPTION <code>visual</code> <p>The napari visual class for the layer.</p> Source code in <code>src/napari_threedee/utils/napari_utils.py</code> <pre><code>def get_napari_visual(viewer, layer):\n\"\"\"Get the visual class for a given layer\n\n    Parameters\n    ----------\n    viewer\n        The napari viewer object\n    layer\n        The napari layer object for which to find the visual.\n\n    Returns\n    -------\n    visual\n        The napari visual class for the layer.\n    \"\"\"\n    visual = viewer.window._qt_window._qt_viewer.layer_to_visual[layer]\n\n    return visual\n</code></pre>"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_dimensions","title":"<code>get_mouse_position_in_displayed_dimensions(event) -&gt; np.ndarray</code>","text":"<p>Get the position under the mouse in scene (displayed world) coordinates.</p> PARAMETER DESCRIPTION <code>event</code> <p>The mouse event.</p> <p> </p> RETURNS DESCRIPTION <code>click_dir_data_3d</code> <p>The click direction in displayed data coordiantes</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>src/napari_threedee/utils/napari_utils.py</code> <pre><code>def get_mouse_position_in_displayed_dimensions(event) -&gt; np.ndarray:\n\"\"\"Get the position under the mouse in scene (displayed world) coordinates.\n\n    Parameters\n    ----------\n    event\n        The mouse event.\n\n    Returns\n    -------\n    click_dir_data_3d : np.ndarray\n        The click direction in displayed data coordiantes\n    \"\"\"\n    click_position_world = event.position\n    return np.asarray(click_position_world)[list(event.dims_displayed)]\n</code></pre>"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_view_direction_in_displayed_dimensions","title":"<code>get_view_direction_in_displayed_dimensions(event) -&gt; np.ndarray</code>","text":"<p>Get the view direction under the mouse in scene (displayed world) coordinates.</p> PARAMETER DESCRIPTION <code>event</code> <p>napari mouse event.</p> <p> </p> Source code in <code>src/napari_threedee/utils/napari_utils.py</code> <pre><code>def get_view_direction_in_displayed_dimensions(event) -&gt; np.ndarray:\n\"\"\"Get the view direction under the mouse in scene (displayed world) coordinates.\n\n    Parameters\n    ----------\n    event: Event\n        napari mouse event.\n    \"\"\"\n    view_direction_world = event.view_direction\n    return np.asarray(view_direction_world)[list(event.dims_displayed)]\n</code></pre>"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_layer_data_coordinates","title":"<code>get_mouse_position_in_displayed_layer_data_coordinates(layer, event) -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>Get the mouse click position and direction in layer data displayed coordinates.</p> PARAMETER DESCRIPTION <code>layer</code> <p>The layer to convert the coordinates to.</p> <p> TYPE: <code>napari.layers.Layer</code> </p> <code>event</code> <p>The mouse event.</p> <p> </p> RETURNS DESCRIPTION <code>click_position_data_3d</code> <p>The click position in displayed data coordinates.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>click_dir_data_3d</code> <p>The click direction in displayed data coordiantes</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>src/napari_threedee/utils/napari_utils.py</code> <pre><code>def get_mouse_position_in_displayed_layer_data_coordinates(layer, event) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"Get the mouse click position and direction in layer data displayed coordinates.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        The layer to convert the coordinates to.\n    event\n        The mouse event.\n\n    Returns\n    -------\n    click_position_data_3d : np.ndarray\n        The click position in displayed data coordinates.\n    click_dir_data_3d : np.ndarray\n        The click direction in displayed data coordiantes\n    \"\"\"\n    click_position_world = event.position\n    click_position_data_3d = np.asarray(\n        layer._world_to_displayed_data(\n            click_position_world,\n            event.dims_displayed\n        )\n    )\n    click_dir_data_3d = np.asarray(\n        layer._world_to_displayed_data_ray(\n            event.view_direction,\n            event.dims_displayed\n        )\n    )\n\n    return click_position_data_3d, click_dir_data_3d\n</code></pre>"},{"location":"API/selection_utilities/","title":"Selection utilities","text":""},{"location":"API/selection_utilities/#selection-utilities","title":"Selection utilities","text":""},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils","title":"<code>napari_threedee.utils.selection_utils</code>","text":""},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.distance_between_point_and_line_segment_2d","title":"<code>distance_between_point_and_line_segment_2d(p, p1, p2)</code>","text":"<p>Calculate the distance between a point p and a line segment p1, p2</p> Source code in <code>src/napari_threedee/utils/selection_utils.py</code> <pre><code>def distance_between_point_and_line_segment_2d(p, p1, p2):\n\"\"\"Calculate the distance between a point p and a line segment p1, p2\n    \"\"\"\n    x0 = p[0]\n    y0 = p[1]\n    x1 = p1[0]\n    y1 = p1[1]\n    x2 = p2[0]\n    y2 = p2[1]\n\n    numerator = np.linalg.norm((x2 - x1) * (y1 - y0) - (x1 - x0) * (y2 - y1))\n    denominator = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    return numerator / denominator\n</code></pre>"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_triangle_from_click","title":"<code>select_triangle_from_click(click_point: np.ndarray, view_direction: np.ndarray, triangles: np.ndarray)</code>","text":"<p>Determine if a line goes through any of a set of triangles.</p> <p>For example, this could be used to determine if a click was in a triangle of a mesh.</p> PARAMETER DESCRIPTION <code>click_point</code> <p>(3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>view_direction</code> <p>(3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>triangles</code> <p>(n, 3, 3) array containing the coordinates for the 3 corners of n triangles.</p> <p> TYPE: <code>np.ndarray</code> </p> RETURNS DESCRIPTION <code>in_triangles</code> <p>(n,) boolean array that is True of the ray intersects the triangle</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>src/napari_threedee/utils/selection_utils.py</code> <pre><code>def select_triangle_from_click(\n        click_point: np.ndarray, view_direction: np.ndarray, triangles: np.ndarray\n):\n\"\"\"Determine if a line goes through any of a set of triangles.\n\n    For example, this could be used to determine if a click was\n    in a triangle of a mesh.\n\n    Parameters\n    ----------\n    click_point : np.ndarray\n        (3,) array containing the location that was clicked. This\n        should be in the same coordinate system as the vertices.\n    view_direction : np.ndarray\n        (3,) array describing the direction camera is pointing in\n        the scene. This should be in the same coordinate system as\n        the vertices.\n    triangles : np.ndarray\n        (n, 3, 3) array containing the coordinates for the 3 corners\n        of n triangles.\n\n    Returns\n    -------\n    in_triangles : np.ndarray\n        (n,) boolean array that is True of the ray intersects the triangle\n    \"\"\"\n    vertices = triangles.reshape((-1, triangles.shape[2]))\n    # project the vertices of the bound region on to the view plane\n    vertices_plane, signed_distance_to_plane = project_points_onto_plane(\n        points=vertices, plane_point=click_point, plane_normal=view_direction\n    )\n\n    # rotate the plane to make the triangles 2D\n    rotation_matrix = rotation_matrix_from_vectors_3d(view_direction, [0, 0, 1])\n    rotated_vertices = vertices_plane @ rotation_matrix.T\n\n    rotated_vertices_2d = rotated_vertices[:, :2]\n    rotated_triangles_2d = rotated_vertices_2d.reshape(-1, 3, 2)\n    line_pos_2D = rotation_matrix.dot(click_point)[:2]\n\n    candidate_matches = inside_triangles(rotated_triangles_2d - line_pos_2D)\n\n    candidate_match_indices = np.argwhere(candidate_matches)\n\n    n_matches = len(candidate_match_indices)\n    if n_matches == 0:\n        triangle_index = None\n    elif n_matches == 1:\n        triangle_index = candidate_match_indices[0]\n    else:\n        potential_match_distances = signed_distance_to_plane[candidate_match_indices]\n        triangle_index = candidate_match_indices[np.argmin(potential_match_distances)]\n\n    return triangle_index\n</code></pre>"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_sphere_from_click","title":"<code>select_sphere_from_click(click_point: np.ndarray, view_direction: np.ndarray, sphere_centroids: np.ndarray, sphere_diameter: float) -&gt; Optional[int]</code>","text":"<p>Determine which, if any spheres are intersected by a click ray.</p> <p>If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned.</p> PARAMETER DESCRIPTION <code>click_point</code> <p>The point where the click ray originates.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>view_direction</code> <p>The unit vector pointing in the direction the viewer is looking.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>sphere_centroids</code> <p>The (n, 3) array of center points for the n points.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>sphere_diameter</code> <p>The diameter of all spheres. Must the same diameter for all spheres.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>selection</code> <p>The index for the sphere that was intersected. Returns None if no spheres are intersected.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>src/napari_threedee/utils/selection_utils.py</code> <pre><code>def select_sphere_from_click(\n    click_point: np.ndarray, view_direction: np.ndarray, sphere_centroids: np.ndarray, sphere_diameter: float\n) -&gt; Optional[int]:\n\"\"\"Determine which, if any spheres are intersected by a click ray.\n\n    If multiple spheres are intersected, the closest sphere to the click point\n    (ray start) will be returned.\n\n    Parameters\n    ----------\n    click_point : np.ndarray\n        The point where the click ray originates.\n    view_direction : np.ndarray\n        The unit vector pointing in the direction the viewer is looking.\n    sphere_centroids : np.ndarray\n        The (n, 3) array of center points for the n points.\n    sphere_diameter : float\n        The diameter of all spheres. Must the same diameter for all spheres.\n\n    Returns\n    -------\n    selection : Optional[int]\n        The index for the sphere that was intersected.\n        Returns None if no spheres are intersected.\n    \"\"\"\n    # project the in view points onto the camera plane\n    projected_points, projection_distances = project_points_onto_plane(\n        points=sphere_centroids,\n        plane_point=click_point,\n        plane_normal=view_direction,\n    )\n\n    # rotate points and plane to be axis aligned with normal [0, 0, 1]\n    rotated_points, rotation_matrix = rotate_points(\n        points=projected_points,\n        current_plane_normal=view_direction,\n        new_plane_normal=[0, 0, 1],\n    )\n    rotated_click_point = np.dot(rotation_matrix, click_point)\n\n    # find the points the click intersects\n    n_spheres = len(sphere_centroids)\n    handle_sizes = np.tile(sphere_diameter, (n_spheres, 1))\n    distances = abs(rotated_points[:, :2] - rotated_click_point[:2])\n\n    # the -1 accounts for the edge width\n    in_slice_matches = np.all(\n        distances &lt;= (handle_sizes - 1 / 2) - 1.5,\n        axis=1,\n    )\n    indices = np.where(in_slice_matches)[0]\n\n    if len(indices) &gt; 0:\n        # find the point that is most in the foreground\n        candidate_point_distances = projection_distances[indices]\n        min_distance_index = np.argmin(candidate_point_distances)\n        selection = indices[min_distance_index]\n    else:\n        selection = None\n\n    return selection\n</code></pre>"},{"location":"annotations/io/","title":"Input/Output","text":""},{"location":"annotations/io/#inputoutput","title":"Input/Output","text":"<p>Annotation layers can be serialized to disk as <code>n3d</code> files. <code>n3d</code> files are <code>zarr</code> files.</p>"},{"location":"annotations/io/#napari-threedee","title":"napari-threedee","text":"<p>napari-threedee implements readers and writers for <code>n3d</code> files.</p>"},{"location":"annotations/io/#python","title":"Python","text":"<p><code>n3d</code> files can be opened in Python with the  zarr  library.</p> <pre><code>import zarr\n\nn3d_data = zarr.load('annotation.n3d')\n</code></pre> <p>These objects contain some attributes allowing them to be  correctly interpreted by napari-threedee. The  attribute <code>annotation_type</code> maps to a specific reader function  napari-threedee will use to load the data.</p> <p></p><pre><code>n3d_data.attrs[\"annotation_type\"]\n</code></pre> <pre><code>Out[2]: 'spline'\n</code></pre>"},{"location":"annotations/io/#other-programming-languages","title":"Other programming languages","text":"<p>For working with <code>n3d</code> (<code>zarr</code>) files in other languages, please look at the  zarr implementations repository.</p>"},{"location":"annotations/point_spec/","title":"Point Specification","text":""},{"location":"annotations/point_spec/#point-specification","title":"Point Specification","text":""},{"location":"annotations/point_spec/#layer-specification","title":"Layer Specification","text":"<p>Point annotations are stored on a napari  <code>Points</code> layer.</p> <ul> <li><code>Points.data</code> is an <code>(n, d)</code> array of n d-dimensional points.</li> <li><code>Points.metadata[\"n3d_metadata\"]</code> is a dictionary with the following    key/value pairs</li> <li><code>annotation_type</code>: <code>point</code></li> </ul>"},{"location":"annotations/point_spec/#zarr-array-specification","title":"Zarr Array Specification","text":"<p>The following assumes an <code>n3d</code> file has been read into a variable called  <code>n3d</code> using the zarr library</p> <pre><code>import zarr\n\nzarr.load('points.n3d')\n</code></pre> <ul> <li><code>n3d</code> is an <code>(n, d)</code> <code>zarr.core.Array</code> containing the points</li> <li><code>n3d.attrs[\"annotation_type\"]</code> is <code>\"sphere\"</code></li> </ul>"},{"location":"annotations/specifications/","title":"Overview","text":""},{"location":"annotations/specifications/#overview","title":"Overview","text":"<p>Annotations made using the annotators from napari-threedee are stored  on a single layer. This layer will match a specification for a given annotation type.</p> <p>Per-point attributes will be stored in the layer features table. Other  metadata will be stored in the layer metadata as a dictionary under the  <code>\"n3d_metadata\"</code> key.</p>"},{"location":"annotations/specifications/#specifications","title":"Specifications","text":"<ul> <li>spline specification (points layer)</li> <li>sphere specification (points layer)</li> <li>point specification (points layer)</li> </ul>"},{"location":"annotations/sphere_spec/","title":"Sphere Specification","text":""},{"location":"annotations/sphere_spec/#sphere-specification","title":"Sphere Specification","text":""},{"location":"annotations/sphere_spec/#layer-specification","title":"Layer Specification","text":"<p>Sphere annotations are stored on a napari  <code>Points</code> layer and  can contain multiple splines.</p> <ul> <li><code>Points.data</code> is an <code>(n, d)</code> array of n d-dimensional points.</li> <li><code>Points.features</code> is a table which will contain column called <ul> <li><code>sphere_id</code>, an integer id for each sphere.</li> <li><code>radius</code>, a radius for each sphere.</li> </ul> </li> <li><code>Points.metadata[\"n3d_metadata\"]</code> is a dictionary with the following    key/value pairs</li> <li><code>annotation_type</code>: <code>sphere</code></li> </ul>"},{"location":"annotations/sphere_spec/#zarr-array-specification","title":"Zarr Array Specification","text":"<p>The following assumes an <code>n3d</code> file has been read into a variable called  <code>n3d</code> using the zarr library</p> <pre><code>import zarr\n\nzarr.load('sphere.n3d')\n</code></pre> <ul> <li><code>n3d</code> is an <code>(n, d)</code> <code>zarr.core.Array</code> containing the center of each sphere</li> <li><code>n3d.attrs[\"annotation_type\"]</code> is <code>\"sphere\"</code></li> <li><code>n3d.attrs[\"sphere_id\"]</code> is an <code>(n, )</code> array containing a unique id for    each sphere</li> <li><code>n3d.attrs[\"radius\"]</code> is an <code>(n, )</code> array containing the radius for each    sphere</li> </ul>"},{"location":"annotations/spline_spec/","title":"Spline Specification","text":""},{"location":"annotations/spline_spec/#spline-specification","title":"Spline Specification","text":""},{"location":"annotations/spline_spec/#layer-specification","title":"Layer Specification","text":"<p>Spline annotations are stored on a napari  <code>Points</code> layer and  can contain multiple splines.</p> <ul> <li><code>Points.data</code> is an <code>(n, d)</code> array of n d-dimensional points.</li> <li><code>Points.features</code> is a table which will contain a column called    <code>spline_id</code>, an integer id for each point.</li> <li><code>Points.metadata[\"n3d_metadata\"]</code> is a dictionary with the following    key/value pairs</li> <li><code>annotation_type</code>: <code>spline</code></li> </ul>"},{"location":"annotations/spline_spec/#zarr-array-specification","title":"Zarr Array Specification","text":"<p>The following assumes an <code>n3d</code> file has been read into a variable called  <code>n3d</code> using the zarr library</p> <pre><code>import zarr\n\nzarr.load('spline.n3d')\n</code></pre> <ul> <li><code>n3d</code> is an <code>(n, d)</code> <code>zarr.core.Array</code></li> <li><code>n3d.attrs[\"annotation_type\"]</code> is <code>\"spline\"</code></li> <li><code>n3d.attrs[\"spline_id\"]</code> is an <code>(n, )</code> array containing the spline id of    each point</li> </ul>"},{"location":"dev_guides/core_concepts/","title":"Core concepts","text":""},{"location":"dev_guides/core_concepts/#core-concepts","title":"Core concepts","text":"<p><code>napari-threedee</code> provides reusable components (called <code>threedee</code> objects) which  - enable custom 3D interactive functionality - simplify the development of workflows with 3D interactivity</p>"},{"location":"dev_guides/core_concepts/#how-to-use-napari-threedee","title":"How to use <code>napari-threedee</code>","text":"<p><code>napari-threedee</code> is designed to be used both as a napari plugin and as a library.</p> <p>When used as a plugin, a set of widgets provide custom 3D manipulation and  annotation tools in napari. In this case, users need not delve into the code.</p> <p>For those who want to integrate custom 3D interactivity into their application,  <code>napari-threedee</code> can also be used as a library. In this case, users can - integrate existing functionality into their applications - develop new custom functionality more easily</p>"},{"location":"dev_guides/core_concepts/#threedee-objects","title":"<code>threedee</code> objects","text":"<p><code>threedee</code> objects can be split into two categories, manipulators and annotators. They can be activated and deactivated as required.</p>"},{"location":"dev_guides/core_concepts/#manipulators","title":"Manipulators","text":"<p>A Manipulator is an object in the scene which allows us to position something.  It is a combination of translators and rotators. </p> <p>Clicking and dragging a translator will move the manipulator in the direction of the translator. Clicking and dragging a rotator will rotate the object.</p> <p>Manipulators can be used to modify other objects by providing callbacks which will  be run before, during and after an interaction with the manipulator. </p> <p>For more details see manipulators</p>"},{"location":"dev_guides/core_concepts/#annotators","title":"Annotators","text":"<p>An Annotator allows for a custom 3D data annotation mode in napari.  This is particularly useful for orchestrating annotation behaviour which depends  on the state of multiple layers (e.g. adding points on planes).</p>"},{"location":"dev_guides/core_concepts/#automatic-widget-generation","title":"Automatic widget generation","text":"<p>A dock widget can be generated automatically for any <code>threedee</code> object by subclassing <code>QtThreeDeeWidgetBase</code> and providing the new <code>threedee</code> object as a model.</p> <pre><code>class QtRenderPlaneManipulatorWidget(QtThreeDeeWidgetBase):\n    def __init__(self,viewer: napari.Viewer, *args, **kwargs):\n        super().__init__(model=RenderPlaneManipulator, viewer=viewer, *args, **kwargs)\n</code></pre>"},{"location":"dev_guides/manipulators/","title":"Manipulators","text":""},{"location":"dev_guides/manipulators/#manipulators","title":"Manipulators","text":"<p>Manipulators are UI elements attached to napari layers to aid with positioning and orienting layer data elements  being displayed on the canvas. Manipulators can translate and rotate along/around specified axes.</p>"},{"location":"dev_guides/manipulators/#coordinate-system","title":"Coordinate system","text":"<p>The manipulator coordinate system is defined with an affine transformation relative to the layer data coordinate system. The manipulator transformation is defined as a translation and a 3x3 transformation matrix (rotation and scale). The  translation is stored in the <code>manipulator.translation</code> property and the transformation is stored in the <code>manipulator. rot_mat</code> property. The rotation is applied before the translation. </p>"},{"location":"dev_guides/manipulators/#translators","title":"Translators","text":"<p>Translators are the UI element on the manipulator responsible for translating the manipulator. When the user  clicks on a translator and drags it, the manipulator is translated by the drag vector component parallel to the  translator direction. </p> <p>Translators are defined by unit vectors pointing in the direction of translation. The unit vectors are stored in the  <code>_initial_translator_normals</code> property as an (n x 3) numpy array for n translators. One translator will be created  for each unit vector in <code>initial_translator_normals</code>.</p>"},{"location":"dev_guides/manipulators/#translator-drag-callback","title":"Translator drag callback","text":"<p>When a translator is dragged, the following callbacks are executed:</p> <ol> <li><code>_pre_drag()</code>: This is called when the translator or rotator is clicked. This is typically used to set up for the     drag callback.</li> <li><code>_while_dragging_translator()</code>: This is called during the drag and is typically used to update layer or manipulator     attributes in response to the translator drag. </li> <li><code>_post_drag()</code>: This is called after the drag has finished. This is generally used to clean up any     variables that were set during the drag or pre drag callbacks.</li> </ol>"},{"location":"dev_guides/manipulators/#implementing-translators","title":"Implementing translators","text":"<p>To add translators to a manipulator, the following must be implemented:</p> <ul> <li><code>_initial_translator_normals</code> must be defined in the <code>__init__()</code> method.</li> <li><code>_pre_drag()</code> callback may be implemented.</li> <li><code>_while_dragging_translator()</code> must be implemented.</li> <li><code>_post_drag()</code> may be implemented.</li> </ul>"},{"location":"dev_guides/manipulators/#rotators","title":"Rotators","text":"<p>Rotators are the UI element on the manipulator responsible for rotating the manipulator. When the user  clicks on a rotator and drags it, the manipulator is rotated around the normal vector of the rotator.</p> <p>Rotators are defined by unit vectors normal to the rotators. The unit vectors are stored in the  <code>_initial_rotators_normals</code> property as an (n x 3) numpy array for n translators. One rotator will be created  for each unit vector in <code>initial_rotator_normals</code>.</p>"},{"location":"dev_guides/manipulators/#rotator-drag-callback","title":"Rotator drag callback","text":"<p>When a rotator is dragged, the following callbacks are executed:</p> <ol> <li><code>_pre_drag()</code>:This is called after the translator or rotator is clicked. This is typically used to set up for the     drag callback.</li> <li><code>_while_dragging_rotator()</code>: This is called during the drag and is typically used to update layer or manipulator     attributes in response to the rotator drag. </li> <li><code>_post_drag()</code>: This is called called after the drag has finished. This is generally used to clean up any     variables that were set during the drag or pre drag callbacks.</li> </ol>"},{"location":"dev_guides/manipulators/#implementing-rotators","title":"Implementing rotators","text":"<p>To add rotators to a manipulator, the following must be implemented:</p> <ul> <li><code>_initial_rotator_normals</code> must be defined in the <code>__init__()</code> method.</li> <li><code>_pre_drag()</code> callback may be implemented.</li> <li><code>_while_dragging_rotator()</code> must be implemented.</li> <li><code>_post_drag()</code> may be implemented.</li> </ul>"},{"location":"dev_guides/manipulators/#notes-on-performance","title":"Notes on performance","text":"<p>In general, writing data to the GPU is slow compared to drawing the scene. Thus, it is recommended that for best  performance, one should move the manipulator in the scene by modifying the transformation rather than modifying the  manipulator definitions (i.e., <code>_initial_translator_normals</code> and <code>_rotator_translator_normals</code>)</p>"},{"location":"generated/gallery/","title":"Examples gallery","text":""},{"location":"generated/gallery/#gallery-for-napari-threedee","title":"Gallery for napari-threedee","text":"<p>Gallery of examples built with napari-threedee.</p>"},{"location":"generated/gallery/#library-examples","title":"Library examples","text":"<p>Examples where napari-threedee is used as a library.</p> <p> Layer manipulator (library) </p> <p> Camera spline (library) </p> <p> Render plane manipulator (library) </p> <p> Mesh headlight (library) </p> <p> Surface annotator (library) </p> <p> Point annotator (library) </p> <p> Path point annotator (library) </p> <p> Sphere annotator (library) </p>"},{"location":"generated/gallery/#plugin-examples","title":"Plugin examples","text":"<p>Examples where napari-threedee is used as a napari plugin.</p> <p> Points manipulator (plugin) </p> <p> Mesh headlight (plugin) </p> <p> Ambient occlusion (plugin) </p> <p> Surface annotator example (plugin) </p> <p> Render plane manipulator (plugin) </p> <p> Layer manipulator (plugin) </p> <p> Camera spline (plugin) </p> <p> Spline annotator (plugin) </p> <p> Plane point annotator (plugin) </p> <p> Sphere annotator (plugin) </p> <p> Path point annotator (plugin) </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/camera_spline_library/","title":"Camera spline (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/camera_spline_library/#camera-spline-library","title":"Camera spline (library)","text":"<p>An example controlling the camera spline, using napari-threedee as a library.</p> <p></p> <pre><code>import napari\nimport skimage\n\nfrom napari_threedee.visualization._qt.qt_camera_spline import QtCameraSpline\n\nviewer = napari.Viewer(ndisplay=3)\nblobs = skimage.data.binary_blobs(\n    length=64,\n    volume_fraction=0.1,\n    n_dim=3\n).astype(float)\n\nplane_parameters_z = {\n    'position': (32, 32, 32),\n    'normal': (1, 0, 0),\n    'thickness': 10,\n}\n\nviewer.add_image(\n    blobs,\n    name='orange plane',\n    rendering='average',\n    colormap='bop orange',\n    depiction='plane',\n    plane=plane_parameters_z\n)\n\ncamera_spline = QtCameraSpline(viewer=viewer)\nviewer.window.add_dock_widget(camera_spline)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.133 seconds)</p> <p> Download Python source code: camera_spline_library.py</p> <p> Download Jupyter notebook: camera_spline_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/layer_manipulator_library/","title":"Layer manipulator (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/layer_manipulator_library/#layer-manipulator-library","title":"Layer manipulator (library)","text":"<p>An example controlling the layer manipulator, using napari-threedee as a library.</p> <p></p> <pre><code>import napari\nimport numpy as np\n\nfrom napari_threedee.manipulators._qt import QtLayerManipulatorWidget\n\ndata = np.random.random((100, 100, 100))\n\nviewer = napari.view_image(data)\nimage_layer = viewer.layers[0]\n\nviewer.dims.ndisplay = 3\n\nwidget = QtLayerManipulatorWidget(viewer)\nviewer.window.add_dock_widget(widget)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  5.524 seconds)</p> <p> Download Python source code: layer_manipulator_library.py</p> <p> Download Jupyter notebook: layer_manipulator_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/mesh_headlight_library/","title":"Mesh headlight (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/mesh_headlight_library/#mesh-headlight-library","title":"Mesh headlight (library)","text":"<p>An example controlling the mesh headlight, using napari-threedee as a library.</p> <p></p> <p>Out:</p> <pre><code>Downloading data from https://raw.githubusercontent.com/vispy/demo-data/main/orig/triceratops.obj.gz (141 kB)\n\n[..................                      ] 45.52059 | downloading   [....................................    ] 91.04119 / downloading   [........................................] 100.00000 - downloading   \nFile saved as /home/runner/.vispy/data/orig/triceratops.obj.gz.\n</code></pre> <p></p> <pre><code>import napari\nimport numpy as np\nfrom vispy.io import load_data_file, read_mesh\n\nfrom napari_threedee.visualization._qt.qt_lighting_control import QtLightingControlWidget\n\n\n# Fetch datasets - this will download dataset if datasets are not found\nvertices, faces, _, _ = read_mesh(load_data_file('orig/triceratops.obj.gz'))\n\n# put the mesh right side up, scale it up (napari#3477) and fix faces handedness\nvertices *= -100\nfaces = faces[:, ::-1]\nvertex_values = np.ones((len(vertices),))\n\n# create an empty viewer\nviewer = napari.Viewer(ndisplay=3)\n\n# add the mesh\nviewer.add_surface((vertices, faces, vertex_values), name='triceratops')\n\nlighting_control_widget = QtLightingControlWidget(viewer=viewer)\nviewer.window.add_dock_widget(widget=lighting_control_widget)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.497 seconds)</p> <p> Download Python source code: mesh_headlight_library.py</p> <p> Download Jupyter notebook: mesh_headlight_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/mg_execution_times/","title":"Computation times","text":""},{"location":"generated/gallery/library/mg_execution_times/#computation-times","title":"Computation times","text":"<p>00:18.823 total execution time for generated_gallery_library files:</p> <p>+---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | layer_manipulator_library (docs/examples/library/layer_manipulator_library.py)                      | 00:05.524 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | surface_annotator_library (docs/examples/library/surface_annotator_library.py)                      | 00:03.316 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | path_annotator_library (docs/examples/library/path_annotator_library.py)                               | 00:02.905 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | point_annotator_library (docs/examples/library/point_annotator_library.py)                            | 00:01.816 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | mesh_headlight_library (docs/examples/library/mesh_headlight_library.py)                               | 00:01.497 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | render_plane_manipulator_library (docs/examples/library/render_plane_manipulator_library.py) | 00:01.428 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | sphere_annotator_library (docs/examples/library/sphere_annotator_library.py)                         | 00:01.205 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | camera_spline_library (docs/examples/library/camera_spline_library.py)                                  | 00:01.133 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/library/path_annotator_library/","title":"Path point annotator (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/path_annotator_library/#path-point-annotator-library","title":"Path point annotator (library)","text":"<p>An example controlling the path annotator, using napari-threedee as a library.</p> <p></p> <pre><code>import napari\nimport numpy as np\nfrom skimage import data\n\nfrom napari_threedee.annotators import PathAnnotator\nfrom napari_threedee.data_models import N3dPaths, N3dPath\n\nCREATE_LAYER_FROM_EXISTING_DATA = True\n\n# create napari viewer\nviewer = napari.Viewer(ndisplay=3)\n\n# generate image data\nblobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=4).astype(float)\n\n# add image layer to viewer (rendering as a plane)\nimage_layer = viewer.add_image(\n    blobs,\n    name='orange plane',\n    rendering='average',\n    colormap='bop orange',\n    blending='translucent',\n    opacity=0.5,\n    depiction='plane',\n    plane={\n        'position': (32, 32, 32),\n        'normal': (1, 0, 0),\n        'thickness': 10,\n    }\n)\n\n# optionally create an n3d compatible points layer from existing data\nif CREATE_LAYER_FROM_EXISTING_DATA is True:\n    path = N3dPath(data=np.random.uniform(low=8, high=56, size=(10, 3)))\n    points_layer = N3dPaths(data=[path]).as_layer()  # list of N3dPath\nelse:\n    points_layer = None\n\n# create the path annotator\nannotator = PathAnnotator(\n    viewer=viewer,\n    image_layer=image_layer,\n    points_layer=points_layer,\n    enabled=True,\n)\n\n# run napari\nviewer.axes.visible = True\nviewer.axes.labels = False\nviewer.camera.angles = (-15, 25, -30)\nviewer.camera.zoom *= 0.5\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  2.905 seconds)</p> <p> Download Python source code: path_annotator_library.py</p> <p> Download Jupyter notebook: path_annotator_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/point_annotator_library/","title":"Point annotator (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/point_annotator_library/#point-annotator-library","title":"Point annotator (library)","text":"<p>An example controlling the point annotator, using napari-threedee as a library.</p> <p></p> <pre><code>import napari\nfrom skimage import data\n\nfrom napari_threedee.annotators import PointAnnotator\n\n\n# create napari viewer\nviewer = napari.Viewer(ndisplay=3)\n\n# generate 3d image data\nblobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)\n\n# add image layer to viewer (rendering as a plane)\nimage_layer = viewer.add_image(\n    blobs,\n    rendering='average',\n    name='plane',\n    colormap='bop orange',\n    blending='translucent',\n    opacity=0.5,\n    depiction='plane',\n    plane={\n        'position': (32, 32, 32),\n        'normal': (1, 0, 0),\n        'thickness': 10,\n    },\n)\n\n# add points layer to viewer\npoints_layer = viewer.add_points(\n    data=[],\n    size=5,\n    face_color='cornflowerblue',\n    ndim=3\n)\n\n# create the point annotator\nannotator = PointAnnotator(\n    viewer=viewer,\n    image_layer=image_layer,\n    points_layer=points_layer,\n    enabled=True,\n)\n\n# run napari\nviewer.layers.selection = [image_layer]\nviewer.axes.visible = True\nviewer.camera.angles = (-15, 25, -30)\nviewer.camera.zoom *= 0.5\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.816 seconds)</p> <p> Download Python source code: point_annotator_library.py</p> <p> Download Jupyter notebook: point_annotator_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/render_plane_manipulator_library/","title":"Render plane manipulator (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/render_plane_manipulator_library/#render-plane-manipulator-library","title":"Render plane manipulator (library)","text":"<p>An example controlling the render plane manipulator, using napari-threedee as a library.</p> <p></p> <pre><code>from napari_threedee.manipulators._qt import QtRenderPlaneManipulatorWidget\n\nimport napari\nfrom skimage import data\n\nviewer = napari.Viewer(ndisplay=3)\nblobs = data.binary_blobs(\n    length=64, volume_fraction=0.1, n_dim=3\n).astype(float)\n\nplane_parameters = {\n    'position': (32, 32, 32),\n    'normal': (1, 0, 0),\n    'thickness': 10,\n}\n\nplane_layer = viewer.add_image(\n    blobs,\n    rendering='average',\n    name='plane',\n    colormap='bop orange',\n    blending='additive',\n    opacity=0.5,\n    depiction='plane',\n    plane=plane_parameters\n)\nvolume_layer = viewer.add_image(\n    blobs, rendering='mip', name='volume', blending='additive', opacity=0.25\n)\n\nwidget = QtRenderPlaneManipulatorWidget(viewer)\nviewer.window.add_dock_widget(widget)\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.428 seconds)</p> <p> Download Python source code: render_plane_manipulator_library.py</p> <p> Download Jupyter notebook: render_plane_manipulator_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/sphere_annotator_library/","title":"Sphere annotator (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/sphere_annotator_library/#sphere-annotator-library","title":"Sphere annotator (library)","text":"<p>An example controlling the sphere annotator, using napari-threedee as a library.</p> <p></p> <pre><code>import napari\nimport numpy as np\nfrom skimage import data\n\nfrom napari_threedee.data_models import N3dSpheres\nfrom napari_threedee.annotators.spheres import SphereAnnotator\n\nCREATE_LAYER_FROM_EXISTING_DATA = True\n\n# create napari viewer\nviewer = napari.Viewer(ndisplay=3)\n\n# generate image data\nblobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)\n\n# add image layer to viewer (rendering as a plane)\nimage_layer = viewer.add_image(\n    blobs,\n    rendering='average',\n    name='plane',\n    colormap='bop orange',\n    blending='translucent',\n    opacity=0.5,\n    depiction='plane',\n    plane={\n        'position': (32, 32, 32),\n        'normal': (1, 0, 0),\n        'thickness': 10,\n    },\n)\n\n# optionally create an n3d compatible points layer from existing data\nif CREATE_LAYER_FROM_EXISTING_DATA is True:\n    centers = np.random.uniform(0, 64, size=(10, 3))\n    radii = np.random.uniform(1, 10, size=(10,))\n    points_layer = N3dSpheres(centers=centers, radii=radii).as_layer()\nelse:\n    points_layer = None\n\n# create the annotator\nannotator = SphereAnnotator(\n    viewer=viewer,\n    image_layer=image_layer,\n    points_layer=points_layer,\n    enabled=True\n)\n\n# run napari\nviewer.axes.visible = True\nviewer.axes.labels = False\nviewer.camera.angles = (-15, 25, -30)\nviewer.camera.zoom *= 0.5\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.205 seconds)</p> <p> Download Python source code: sphere_annotator_library.py</p> <p> Download Jupyter notebook: sphere_annotator_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/library/surface_annotator_library/","title":"Surface annotator (library)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/library/surface_annotator_library/#surface-annotator-library","title":"Surface annotator (library)","text":"<p>An example controlling the surface annotator, using napari-threedee as a library.</p> <p></p> <pre><code>import napari\nfrom skimage import data\n\nimport napari_threedee as n3d\n\n# create napari viewer\nviewer = napari.Viewer(ndisplay=3)\n\n# generate 3d image data\nblobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)\n\n# add image layer to viewer (rendering as plane)\nimage_layer = viewer.add_image(\n    blobs,\n    name='orange plane',\n    rendering='average',\n    colormap='bop orange',\n    blending='translucent',\n    opacity=0.5,\n    depiction='plane',\n    plane={\n        'position': (32, 32, 32),\n        'normal': (1, 0, 0),\n        'thickness': 10,\n    })\n\n# create annotator\nannotator = n3d.annotators.SurfaceAnnotator(\n    viewer=viewer, image_layer=image_layer, enabled=True\n)\n\n# run napari\nviewer.layers.selection = [image_layer]\nviewer.axes.visible = True\nviewer.axes.labels = False\nviewer.camera.angles = (-15, 25, -30)\nviewer.camera.zoom *= 0.5\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  3.316 seconds)</p> <p> Download Python source code: surface_annotator_library.py</p> <p> Download Jupyter notebook: surface_annotator_library.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/ambient_occlusion_plugin/","title":"Ambient occlusion (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/ambient_occlusion_plugin/#ambient-occlusion-plugin","title":"Ambient occlusion (plugin)","text":"<p>An example adding ambient occlusion to a mesh, using napari-threedee as a napari plugin.</p> <p></p> <pre><code>import napari\nimport numpy as np\nfrom vispy.io import load_data_file, read_mesh\n\n\n# Fetch datasets - this will download dataset if datasets are not found\nvertices, faces, _, _ = read_mesh(load_data_file('orig/triceratops.obj.gz'))\n\n# put the mesh right side up, scale it up (napari#3477) and fix faces handedness\nvertices *= -100\nfaces = faces[:, ::-1]\nvertex_values = np.ones((len(vertices)))\n\n# create an empty viewer\nviewer = napari.Viewer(ndisplay=3)\n\n# add the mesh\nviewer.add_surface((vertices, faces, vertex_values), name='triceratops', shading=\"smooth\")\n\n# open the plugin\nviewer.window.add_plugin_dock_widget(\n    plugin_name=\"napari-threedee\", widget_name=\"ambient occlusion controls\"\n)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.972 seconds)</p> <p> Download Python source code: ambient_occlusion_plugin.py</p> <p> Download Jupyter notebook: ambient_occlusion_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/camera_spline_plugin/","title":"Camera spline (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/camera_spline_plugin/#camera-spline-plugin","title":"Camera spline (plugin)","text":"<p>An example controlling the camera spline, using napari-threedee as a napari plugin.</p> <p></p> <p>```{.python } import napari import skimage</p> <p>viewer = napari.Viewer(ndisplay=3) blobs = skimage.data.binary_blobs(     length=64,     volume_fraction=0.1,     n_dim=3 ).astype(float)</p> <p>plane_parameters_z = {     'position': (32, 32, 32),     'normal': (1, 0, 0),     'thickness': 10, }</p> <p>plane_parameters_y = {     'position': (32, 32, 32),     'normal': (0, 1, 0),     'thickness': 10, }</p> <p>viewer.add_image(     blobs,     name='orange plane',     rendering='average',     colormap='bop orange',     blending='additive',     opacity=0.5,     depiction='plane',     plane=plane_parameters_z)</p> <p>viewer.add_image(     blobs,     name='blue plane',     rendering='average',     colormap='bop blue',     blending='additive',     opacity=0.5,     depiction='plane',     plane=plane_parameters_y)</p> <p>viewer.window.add_plugin_dock_widget(     plugin_name=\"napari-threedee\", widget_name=\"camera spline control\" )</p> <p>viewer.camera.angles = (60, 60, 60) napari.run()```</p> <p>Total running time of the script: ( 0 minutes  1.281 seconds)</p> <p> Download Python source code: camera_spline_plugin.py</p> <p> Download Jupyter notebook: camera_spline_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/layer_manipulator_plugin/","title":"Layer manipulator (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/layer_manipulator_plugin/#layer-manipulator-plugin","title":"Layer manipulator (plugin)","text":"<p>An example controlling the layer manipulator, using napari-threedee as a napari plugin.</p> <p></p> <p>Out:</p> <pre><code>/home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ('Window._qt_window') in this context (e.g. inside a plugin widget or dock widget) is deprecated and will be unavailable in version 0.5.0\n  visual = viewer.window._qt_window._qt_viewer.layer_to_visual[layer]\n/home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ('_QtMainWindow._qt_viewer') in this context (e.g. inside a plugin widget or dock widget) is deprecated and will be unavailable in version 0.5.0\n  visual = viewer.window._qt_window._qt_viewer.layer_to_visual[layer]\n</code></pre> <p></p> <pre><code>import napari\n\ntry:\n    from skimage.data import binary_blobs\nexcept ImportError:\n    raise ImportError(\"This example requires scikit-image. pip install scikit-image\")\n\n\nimage = binary_blobs(\n    50,\n    n_dim=3,\n    blob_size_fraction=0.3,\n    volume_fraction=0.1,\n)\n\nviewer = napari.view_image(\n    image,\n    colormap=\"magenta\",\n    opacity=0.8,\n    blending=\"additive\",\n    rendering=\"iso\",\n    iso_threshold=0,\n    name=\"image_0\",\n)\nimage_layer_0 = viewer.layers[0]\n\n# add an addition layer that is shifted\nimage_layer_1 = viewer.add_image(\n    image.copy(),\n    colormap=\"green\",\n    opacity=0.8,\n    blending=\"additive\",\n    rendering=\"iso\",\n    iso_threshold=0,\n    name=\"image_1\",\n    translate=(20, 20, 20),\n)\n\nviewer.dims.ndisplay = 3\n\nviewer.window.add_plugin_dock_widget(\n    plugin_name=\"napari-threedee\", widget_name=\"layer manipulator\"\n)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  6.639 seconds)</p> <p> Download Python source code: layer_manipulator_plugin.py</p> <p> Download Jupyter notebook: layer_manipulator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/mesh_headlight_plugin/","title":"Mesh headlight (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/mesh_headlight_plugin/#mesh-headlight-plugin","title":"Mesh headlight (plugin)","text":"<p>An example controlling the mesh headlight, using napari-threedee as a napari plugin.</p> <p></p> <pre><code>import napari\nimport numpy as np\nfrom vispy.io import load_data_file, read_mesh\n\n\n# Fetch datasets - this will download dataset if datasets are not found\nvertices, faces, _, _ = read_mesh(load_data_file('orig/triceratops.obj.gz'))\n\n# put the mesh right side up, scale it up (napari#3477) and fix faces handedness\nvertices *= -100\nfaces = faces[:, ::-1]\nvertex_values = np.ones((len(vertices),))\n\n# create an empty viewer\nviewer = napari.Viewer(ndisplay=3)\n\n# add the mesh\nviewer.add_surface((vertices, faces, vertex_values), name='triceratops')\n\n# open the plugin\nviewer.window.add_plugin_dock_widget(\n    plugin_name=\"napari-threedee\", widget_name=\"mesh lighting controls\"\n)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.964 seconds)</p> <p> Download Python source code: mesh_headlight_plugin.py</p> <p> Download Jupyter notebook: mesh_headlight_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/mg_execution_times/","title":"Computation times","text":""},{"location":"generated/gallery/plugin/mg_execution_times/#computation-times","title":"Computation times","text":"<p>00:22.996 total execution time for generated_gallery_plugin files:</p> <p>+-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | layer_manipulator_plugin (docs/examples/plugin/layer_manipulator_plugin.py)                      | 00:06.639 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | path_annotator_plugin (docs/examples/plugin/path_annotator_plugin.py)                               | 00:03.163 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | point_annotator_plugin (docs/examples/plugin/point_annotator_plugin.py)                            | 00:02.382 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | spline_annotator_plugin (docs/examples/plugin/spline_annotator_plugin.py)                         | 00:01.748 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | render_plane_manipulator_plugin (docs/examples/plugin/render_plane_manipulator_plugin.py) | 00:01.698 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | sphere_annotator_plugin (docs/examples/plugin/sphere_annotator_plugin.py)                         | 00:01.678 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | surface_annotator_plugin (docs/examples/plugin/surface_annotator_plugin.py)                      | 00:01.565 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | camera_spline_plugin (docs/examples/plugin/camera_spline_plugin.py)                                  | 00:01.281 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | ambient_occlusion_plugin (docs/examples/plugin/ambient_occlusion_plugin.py)                      | 00:00.972 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | mesh_headlight_plugin (docs/examples/plugin/mesh_headlight_plugin.py)                               | 00:00.964 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | points_manipulator_plugin (docs/examples/plugin/points_manipulator_plugin.py)                   | 00:00.907 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/plugin/path_annotator_plugin/","title":"Path point annotator (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/path_annotator_plugin/#path-point-annotator-plugin","title":"Path point annotator (plugin)","text":"<p>An example controlling the path annotator, using napari-threedee as a napari plugin.</p> <p></p> <p>```{.python } import napari from skimage import data</p>"},{"location":"generated/gallery/plugin/path_annotator_plugin/#create-napari-viewer","title":"create napari viewer","text":"<p>viewer = napari.Viewer(ndisplay=3)</p>"},{"location":"generated/gallery/plugin/path_annotator_plugin/#generate-image-data","title":"generate image data","text":"<p>blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=4).astype(float)</p>"},{"location":"generated/gallery/plugin/path_annotator_plugin/#add-two-image-layers-to-viewer","title":"add two image layers to viewer","text":"<p>viewer.add_image(     blobs,     name='orange plane',     rendering='average',     colormap='bop orange',     blending='translucent',     opacity=0.5,     depiction='plane',     plane={         'position': (32, 32, 32),         'normal': (1, 0, 0),         'thickness': 10,     } )</p> <p>viewer.add_image(     blobs,     name='blue plane',     rendering='average',     colormap='bop blue',     blending='additive',     opacity=0.5,     depiction='plane',     plane={         'position': (32, 32, 32),         'normal': (0, 1, 0),         'thickness': 10,     } )</p>"},{"location":"generated/gallery/plugin/path_annotator_plugin/#add-plugin-dock-widget-to-viewer","title":"add plugin dock widget to viewer","text":"<p>viewer.window.add_plugin_dock_widget(     plugin_name=\"napari-threedee\", widget_name=\"path annotator\" )</p>"},{"location":"generated/gallery/plugin/path_annotator_plugin/#run-napari","title":"run napari","text":"<p>viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()```</p> <p>Total running time of the script: ( 0 minutes  3.163 seconds)</p> <p> Download Python source code: path_annotator_plugin.py</p> <p> Download Jupyter notebook: path_annotator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/point_annotator_plugin/","title":"Plane point annotator (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/point_annotator_plugin/#plane-point-annotator-plugin","title":"Plane point annotator (plugin)","text":"<p>An example controlling the point annotator, using napari-threedee as a napari plugin.</p> <p></p> <p>```{.python } import napari from skimage import data</p>"},{"location":"generated/gallery/plugin/point_annotator_plugin/#create-napari-viewer","title":"create napari viewer","text":"<p>viewer = napari.Viewer(ndisplay=3)</p>"},{"location":"generated/gallery/plugin/point_annotator_plugin/#generate-image-data","title":"generate image data","text":"<p>blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=4).astype(float)</p>"},{"location":"generated/gallery/plugin/point_annotator_plugin/#add-two-image-layers-to-viewer","title":"add two image layers to viewer","text":"<p>viewer.add_image(     blobs,     name='orange plane',     rendering='average',     colormap='bop orange',     blending='translucent',     opacity=0.5,     depiction='plane',     plane={     'position': (32, 32, 32),     'normal': (1, 0, 0),     'thickness': 10, })</p> <p>viewer.add_image(     blobs,     name='blue plane',     rendering='average',     colormap='bop blue',     blending='additive',     opacity=0.5,     depiction='plane',     plane={     'position': (32, 32, 32),     'normal': (0, 1, 0),     'thickness': 10, })</p>"},{"location":"generated/gallery/plugin/point_annotator_plugin/#add-plugin-dock-widget-to-viewer","title":"add plugin dock widget to viewer","text":"<p>viewer.window.add_plugin_dock_widget(     plugin_name=\"napari-threedee\", widget_name=\"point annotator\" )</p>"},{"location":"generated/gallery/plugin/point_annotator_plugin/#run-napari","title":"run napari","text":"<p>viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()```</p> <p>Total running time of the script: ( 0 minutes  2.382 seconds)</p> <p> Download Python source code: point_annotator_plugin.py</p> <p> Download Jupyter notebook: point_annotator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/points_manipulator_plugin/","title":"Points manipulator (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/points_manipulator_plugin/#points-manipulator-plugin","title":"Points manipulator (plugin)","text":"<p>Example of using the points manipulator to re-position points, using napari-threedee as a napari plugin.</p> <p>Enter the point selection mode and click on a point to activate the manipulator. Click and drag the arms of the manipulator to move the point. When a point is selected, hold space to rotate the view without losing the selection.</p> <p></p> <pre><code>import numpy as np\n\nimport napari\n\npoints_data = np.array(\n    [\n        [0, 0, 0],\n        [0, 200, 0],\n        [0, 0, 200]\n    ]\n)\n\nviewer = napari.Viewer(ndisplay=3)\npoints_layer = viewer.add_points(points_data, size=5)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.907 seconds)</p> <p> Download Python source code: points_manipulator_plugin.py</p> <p> Download Jupyter notebook: points_manipulator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/render_plane_manipulator_plugin/","title":"Render plane manipulator (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/render_plane_manipulator_plugin/#render-plane-manipulator-plugin","title":"Render plane manipulator (plugin)","text":"<p>An example controlling the render plane manipulator, using napari-threedee as a napari plugin.</p> <p></p> <p>Out:</p> <pre><code>/home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ('Window._qt_window') in this context (e.g. inside a plugin widget or dock widget) is deprecated and will be unavailable in version 0.5.0\n  visual = viewer.window._qt_window._qt_viewer.layer_to_visual[layer]\n/home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ('_QtMainWindow._qt_viewer') in this context (e.g. inside a plugin widget or dock widget) is deprecated and will be unavailable in version 0.5.0\n  visual = viewer.window._qt_window._qt_viewer.layer_to_visual[layer]\n</code></pre> <p></p> <pre><code>import napari\nfrom skimage import data\n\n\nviewer = napari.Viewer(ndisplay=3)\n\n# add a volume\nblobs = data.binary_blobs(\n    length=64, volume_fraction=0.1, n_dim=3\n).astype(float)\nvolume_layer = viewer.add_image(\n    blobs, rendering='mip', name='volume', blending='additive', opacity=0.25\n)\n\n# add the same volume and render as plane\n# plane should be in 'additive' blending mode or depth looks all wrong\nplane_parameters = {\n    'position': (32, 32, 32),\n    'normal': (1, 0, 0),\n    'thickness': 10,\n}\n\nplane_layer = viewer.add_image(\n    blobs,\n    rendering='average',\n    name='plane',\n    colormap='bop orange',\n    blending='additive',\n    opacity=0.5,\n    depiction=\"plane\",\n    plane=plane_parameters\n)\n\nviewer.window.add_plugin_dock_widget(\n    plugin_name=\"napari-threedee\", widget_name=\"render plane manipulator\"\n)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.698 seconds)</p> <p> Download Python source code: render_plane_manipulator_plugin.py</p> <p> Download Jupyter notebook: render_plane_manipulator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/","title":"Sphere annotator (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#sphere-annotator-plugin","title":"Sphere annotator (plugin)","text":"<p>An example controlling the sphere annotator, using napari-threedee as a napari plugin.</p> <p></p> <p>```{.python } import napari from skimage import data</p>"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#create-napari-viewer","title":"create napari viewer","text":"<p>viewer = napari.Viewer(ndisplay=3)</p>"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#generate-image-data","title":"generate image data","text":"<p>blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)</p>"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#add-two-image-layers-to-viewer","title":"add two image layers to viewer","text":"<p>viewer.add_image(     blobs,     name='orange plane',     rendering='average',     colormap='bop orange',     blending='translucent',     opacity=0.5,     depiction='plane',     plane={     'position': (32, 32, 32),     'normal': (1, 0, 0),     'thickness': 10, })</p> <p>viewer.add_image(     blobs,     name='blue plane',     rendering='average',     colormap='bop blue',     blending='additive',     opacity=0.5,     depiction='plane',     plane={     'position': (32, 32, 32),     'normal': (0, 1, 0),     'thickness': 10, })</p>"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#add-plugin-dock-widget-to-viewer","title":"add plugin dock widget to viewer","text":"<p>viewer.window.add_plugin_dock_widget(     plugin_name=\"napari-threedee\", widget_name=\"sphere annotator\" )</p>"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#run-napari","title":"run napari","text":"<p>viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()```</p> <p>Total running time of the script: ( 0 minutes  1.678 seconds)</p> <p> Download Python source code: sphere_annotator_plugin.py</p> <p> Download Jupyter notebook: sphere_annotator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/spline_annotator_plugin/","title":"Spline annotator (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#spline-annotator-plugin","title":"Spline annotator (plugin)","text":"<p>An example controlling the spline annotator, using napari-threedee as a napari plugin.</p> <p></p> <p>```{.python } import napari from skimage import data</p>"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#create-napari-viewer","title":"create napari viewer","text":"<p>viewer = napari.Viewer(ndisplay=3)</p>"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#generate-image-data","title":"generate image data","text":"<p>blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)</p>"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#add-two-image-layers-to-viewer","title":"add two image layers to viewer","text":"<p>viewer.add_image(     blobs,     name='orange plane',     rendering='average',     colormap='bop orange',     blending='translucent',     opacity=0.5,     depiction='plane',     plane={     'position': (32, 32, 32),     'normal': (1, 0, 0),     'thickness': 10, })</p> <p>viewer.add_image(     blobs,     name='blue plane',     rendering='average',     colormap='bop blue',     blending='additive',     opacity=0.5,     depiction='plane',     plane={     'position': (32, 32, 32),     'normal': (0, 1, 0),     'thickness': 10, })</p>"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#add-plugin-dock-widget-to-viewer","title":"add plugin dock widget to viewer","text":"<p>viewer.window.add_plugin_dock_widget(     plugin_name=\"napari-threedee\", widget_name=\"path annotator\" )</p>"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#run-napari","title":"run napari","text":"<p>viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()```</p> <p>Total running time of the script: ( 0 minutes  1.748 seconds)</p> <p> Download Python source code: spline_annotator_plugin.py</p> <p> Download Jupyter notebook: spline_annotator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plugin/surface_annotator_plugin/","title":"Surface annotator example (plugin)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#surface-annotator-example-plugin","title":"Surface annotator example (plugin)","text":"<p>An example controlling the surface annotator, using napari-threedee as a napari plugin.</p> <p></p> <p>```{.python }</p> <p>import napari from skimage import data</p>"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#create-napari-viewer","title":"create napari viewer","text":"<p>viewer = napari.Viewer(ndisplay=3)</p>"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#generate-image-data","title":"generate image data","text":"<p>blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)</p>"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#add-an-image-layers-to-the-viewer","title":"add an image layers to the viewer","text":"<p>viewer.add_image(     blobs,     name='orange plane',     rendering='average',     colormap='bop orange',     blending='translucent',     opacity=0.5,     depiction='plane',     plane={     'position': (32, 32, 32),     'normal': (1, 0, 0),     'thickness': 10, })</p>"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#add-plugin-dock-widget-to-viewer","title":"add plugin dock widget to viewer","text":"<p>viewer.window.add_plugin_dock_widget(     plugin_name=\"napari-threedee\", widget_name=\"surface annotator\" )</p>"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#run-napari","title":"run napari","text":"<p>viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()```</p> <p>Total running time of the script: ( 0 minutes  1.565 seconds)</p> <p> Download Python source code: surface_annotator_plugin.py</p> <p> Download Jupyter notebook: surface_annotator_plugin.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"getting_started/developers/","title":"for developers","text":""},{"location":"getting_started/developers/#geting-started-for-developers","title":"Geting started for developers","text":"<p>To get started developing plugins or applications that depend on napari-threedee, we recommend viewing our explanatory documentation the describes how the different components are designed:</p> <ul> <li>Explanation of the core concepts</li> <li>Explanation of the manipulators</li> <li>Explanation of the annotation specifications</li> </ul>"},{"location":"getting_started/users/","title":"for users","text":""},{"location":"getting_started/users/#getting-started-for-users","title":"Getting started for users","text":"<p>If you would like to get started using the napari-threedee plugins, we recommend reviewing the following documentation:</p> <ul> <li>We have created tutorials in the \"How to...\" section. For example, read about how to interactively position a render plane</li> <li>Gallery of examples of plugins that depend on <code>napari-threedee</code>.</li> </ul>"},{"location":"how_to/ambient_occlusion/","title":"add ambient occlusion to a surface","text":""},{"location":"how_to/ambient_occlusion/#add-ambient-occlusion-to-surfaces","title":"Add ambient occlusion to surfaces","text":""},{"location":"how_to/ambient_occlusion/#summary","title":"Summary","text":"<p>Ambient occlusion is a rendering technique that can be used to Adding ambient occlusion can help improve the depth in the image and make detailed surfaces more clear. In this tutorial, you will learn how to apply ambient occlusion to a napari surface layer using the \"ambient occlusion controls\" plugin.</p> <p></p>"},{"location":"how_to/ambient_occlusion/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the <code>ambient_occlusion_plugin.py</code> example. The viewer is initialized in 3D rendering mode and should display a mesh of a triceratops.</p> <p></p> </li> <li> <p>Select the \"triceratops\" layer from the plugin selection box and click the \"update ambient occlusion\" button. This should complete quickly for the triceratops mesh. For larger meshes, this will take longer.</p> <p></p> </li> <li> <p>You should now see the triceratops has shadows in regions that would be blocked from ambient light.</p> <p></p> </li> <li> <p>You can deactivate the ambient occlusion by de-selecting the layer in the plugin selection box and clicking the \"update ambient occlusion\" button.</p> <p></p> </li> </ol>"},{"location":"how_to/layer_manipulator/","title":"interactively position layers","text":""},{"location":"how_to/layer_manipulator/#how-to-position-layers-with-the-layer-manipulator","title":"How to position layers with the layer manipulator","text":""},{"location":"how_to/layer_manipulator/#summary","title":"Summary","text":"<p>Sometimes objects in your data have a systematic shift relative to one another. If you need to position an entire dataset, you can use the layer manipulator. This article describes how to interactively position a layer using the layer manipulator.</p> <p></p>"},{"location":"how_to/layer_manipulator/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the layer_manipulator.py example from the docs. The viewer is initalized in 3D rendering mode. You can click and drag in the canvas to rotate the view. Note that the two layers are the same image, but not aligned.</p> <p></p> </li> <li> <p>Select the \"image_1\" layer in the layer manipulator plugin. We will move layer \"image_1\" (the green one) to be aligned with layer \"image_0\".</p> <p></p> </li> <li> <p>Activate the layer manipulator plugin.</p> <p></p> <p>When the plugin is activated, you will see the manipulator at (0, 0, 0) on image_1.</p> <p></p> </li> <li> <p>Click and drag the manipulator to align the rows. Since the layers are being rendered with additive blending, the image turns white where the layers are overlapping.</p> <p></p> </li> </ol>"},{"location":"how_to/point_annotator/","title":"annotate points in 3D","text":""},{"location":"how_to/point_annotator/#annotate-points-on-an-arbitrary-plane","title":"Annotate points on an arbitrary plane","text":""},{"location":"how_to/point_annotator/#summary","title":"Summary","text":"<p>Annotating points in 3D can be useful for picking particles in CryoET and annotating locations of landmarks. However, doing so on a 2D computer screen is challenging. Here we demonstrate how to use the point annotator, which annotates points on arbitrary slicing planes.</p> <p></p>"},{"location":"how_to/point_annotator/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the <code>plane_point_annotator.py</code> example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing two 3D volumes, each with one plane being actively rendered.</p> <p></p> </li> <li> <p>Activate the plugin. Select the <code>orange</code> layer for the \"image layer\" and <code>Points</code> for the \"points layer\". Finally click the \"activate\" button. This will add points to the <code>Points</code> layer based on the intersection of the click ray with the currently rendered <code>orange</code> layer.</p> <p></p> </li> <li> <p>You can translate the rendered orange play along its normal vector by holding the shift key while clicking  with the left mouse button and dragging the plane.</p> <p></p> </li> <li> <p>You can add points on the rendered plane by holding the alt key while clicking with the left mouse button. You can move the plane to annotate a new plane by clicking and dragging with the shift key as in step 3.</p> <p></p> </li> </ol>"},{"location":"how_to/point_manipulator/","title":"interactively position points","text":""},{"location":"how_to/point_manipulator/#how-to-position-points-with-the-point-manipulator","title":"How to position points with the point manipulator","text":""},{"location":"how_to/point_manipulator/#summary","title":"Summary","text":"<p>Precisely positioning a point in 3D is a useful way to annotate specific positions or choose the location of an object in a scene. This article explains how to use the <code>napari-threedee</code> point manipulator plugin to position points in 3D.</p> <p></p>"},{"location":"how_to/point_manipulator/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the points_manipulator.py example.</p> <p>    The example opens in 3D rendering mode. Click and drag to rotate the view.</p> </li> <li> <p>Open the point manipulator plugin from the Plugins menu: Plugins -&gt; napari-threedee -&gt; point manipulator. Click the \"activate\" to start the plugin.</p> <p></p> </li> <li> <p>Set the Points later to \"Selection\" mode by clicking the \"Selection\" button in the layer controls</p> <p></p> </li> <li> <p>Select a point by clicking on it. The point manipulator will appear on the selected point.</p> <p></p> </li> <li> <p>You can now move the point around by clicking and dragging the manipulator.</p> <p></p> <p>If you want to rotate the view while a point manipulator is active, press and hold the space bar while clicking and dragging in the canvas to rotate the view. The manipulator will be rendered invisible while you rotate so you can see the whole scene.</p> <p></p> </li> </ol>"},{"location":"how_to/render_plane_manipulator/","title":"interactively position a render plane","text":""},{"location":"how_to/render_plane_manipulator/#how-to-use-the-render-plane-manipulator","title":"How to use the render plane manipulator","text":""},{"location":"how_to/render_plane_manipulator/#summary","title":"Summary","text":"<p>The render plane manipulator allows you to interactively position the plane being visualized in the <code>napari</code> <code>Image</code>  layer plane depiction mode. The plane depiction mode is a 3D rendering mode where only the specified plane is  rendered. This is a power rendering mode for visualizing structures within a 3D volume, but defining the precise  plane programatically can be challenging. Thus, the render plane manipulator is useful for interactively positioning  the rendering plane.</p> <p></p>"},{"location":"how_to/render_plane_manipulator/#instructions","title":"Instructions","text":"<ol> <li> <p>Launch <code>napari</code>. Open your terminal and activate your <code>napari-threedee</code> environment. Enter <code>napari</code> in the     command prompt to launch napari.</p> <pre><code>napari\n</code></pre> </li> <li> <p>Load the \"HIV virus-like particles tomogram\" image from the File menu: File -&gt; Open Sample -&gt; HIV virus-like particle tomogram. Note that this will download the sample image so it make take some time. If you have previously opened the sample image, it should be cached and will not download again.</p> <p></p> </li> <li> <p>Click the \"Toggle ndisplay\" button in the lower left corner of the viewer to enter 3D rendering mode. </p> <p></p> <p>Upon clicking the button, you will see the volume in 3D. You you can click and drag to rotate the view. Note that the HIV particles are visible, but low contrast.</p> <p></p> </li> <li> <p>In the layer controls, change the <code>depiction</code> mode from <code>volume</code> to <code>plane</code>.</p> <p></p> <p>After changing the depiction mode, you will see a single plane being rendered from your 3d volume.</p> <p></p> </li> <li> <p>Open the render plane manipulator plugin from the menu: Plugins -&gt; napari-threedee -&gt; render plane manipulator. You will see the render plane manipulator appear on the rendering plane.</p> <p></p> </li> <li> <p>You can click and drag the translator on the manipulator to translate the plane along its normal.</p> <p></p> </li> <li> <p>You can click and drag the rotator to rotate the plane around the manipulator.</p> <p></p> <p>If you would like to change the center of rotation, you can press the shift key while clicking on the plane with the left mouse button to move the manipulator.</p> <p></p> </li> </ol>"},{"location":"how_to/sphere_annotator/","title":"annotate spheres in 3D","text":""},{"location":"how_to/sphere_annotator/#annotate-spheres-on-arbitrary-planes","title":"Annotate spheres on arbitrary planes","text":""},{"location":"how_to/sphere_annotator/#summary","title":"Summary","text":"<p>Annotating spheres in 3D is useful for defining regions of interest around a point. Here we describe how to annotate a sphere on an arbitrary plane in an image.</p> <p></p>"},{"location":"how_to/sphere_annotator/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the <code>sphere_annotator.py</code> example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing a 3D volume with one plane being actively rendered.</p> <p></p> </li> <li> <p>Activate the plugin. Select the <code>plane</code> layer for the \"image layer\" and click the \"activate\" button. This will add points to the <code>Points</code> layer based on the intersection of the click ray with the currently rendered <code>orange</code> layer.</p> <p></p> </li> <li> <p>You can translate the rendered orange play along its normal vector by holding the shift key while clicking  with the left mouse button and dragging the plane.</p> <p></p> </li> <li> <p>You can add a sphere on the rendered play by holding alt and clicking on the plane with the left mouse button. If you alt+click again, it will reposition the sphere.</p> </li> </ol> <p></p> <ol> <li>You can adjust the radius of the sphere by presing the <code>r</code> key and the sphere will snap to the position where your mouse pointer intersects the rendered plane.</li> </ol> <p></p> <ol> <li>You add a new point by pressing the <code>n</code> key and repeating steps 5 and 6.</li> </ol> <p></p>"},{"location":"how_to/spline_annotator/","title":"annotate splines in 3D","text":""},{"location":"how_to/spline_annotator/#annotate-3d-splines","title":"Annotate 3D splines","text":""},{"location":"how_to/spline_annotator/#summary","title":"Summary","text":"<p>Spines are useful for describing paths through your data. This tutorial describes how use the spline annotator to interactively add splines in a 3D image.</p> <p></p>"},{"location":"how_to/spline_annotator/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the <code>spline_annotator.py</code> example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing two 3D volumes, each with one plane being actively rendered.</p> <p></p> </li> <li> <p>Activate the plugin. Select the <code>orange</code> layer for the \"image layer\" and click the \"activate\" button.</p> <p></p> </li> <li> <p>You can translate the rendered orange play along its normal vector by holding the shift key while clicking  with the left mouse button and dragging the plane.</p> <p></p> </li> <li> <p>You can add a spline by ctrl+left mouse button clicking on the rendered plane to add points to the plane. The annotator will fit a third order spline when 4 or more points have been added. If you don't want the spline to be automatically fit, you can uncheck the \"automatically fit spline\" checkbox. If you are not automatically fitting the spline, you need to click the \"fit spline\" button to manually initiate the spline fitting.</p> <p></p> </li> <li> <p>You can add additional splines by advancing the \"current spline index\". Each spline is given a unique index. Points are added to the spline whose index is currently selected. Additionally, to make a spline that doesn't lie in a single plane, you can add points to mutiple planes by moving the rendered plane.</p> <p></p> </li> </ol>"},{"location":"tutorials/tutorials/","title":"Tutorials","text":""}]}