{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview napari-threedee is a collection of tools for exploring, manipulating, and annotating your data in 3D. Installation napari-threedee is a napari plugin and thus requires napari to work. You can see the napari documentation for napari installation instructions . After you have installed napari , you can install napari-threedee using the package manager of your choice using the commands below. pip conda pip install napari-threedee conda install -c conda-forge napari-threedee Getting started Users Do you have rich 3D (or more!) data that you want to explore and annotate? napari-threedee comes with a collection of plugins for just that. Please see our Getting started for users guide to get going. Developers Are you developing an image processing workflow that requires exploration or annotation of multidimensional data? napari-threedee has a collection of composable compoents for adding 3D interactivity to your workflow! To get started, see our Getting started for developers guide .","title":"Overview"},{"location":"#overview","text":"napari-threedee is a collection of tools for exploring, manipulating, and annotating your data in 3D.","title":"Overview"},{"location":"#installation","text":"napari-threedee is a napari plugin and thus requires napari to work. You can see the napari documentation for napari installation instructions . After you have installed napari , you can install napari-threedee using the package manager of your choice using the commands below. pip conda pip install napari-threedee conda install -c conda-forge napari-threedee","title":"Installation"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#users","text":"Do you have rich 3D (or more!) data that you want to explore and annotate? napari-threedee comes with a collection of plugins for just that. Please see our Getting started for users guide to get going.","title":"Users"},{"location":"#developers","text":"Are you developing an image processing workflow that requires exploration or annotation of multidimensional data? napari-threedee has a collection of composable compoents for adding 3D interactivity to your workflow! To get started, see our Getting started for developers guide .","title":"Developers"},{"location":"API/geometry_utilities/","text":"Geometry utilities napari_threedee.utils.geometry signed_angle_between_vectors ( vector_0 , vector_1 , rotation_axis : np . ndarray ) -> float Returns the angle in radians between vectors 'v1' and 'v2'. PARAMETER DESCRIPTION vector_0 The vector to start the rotation at. TYPE: np . ndarray vector_1 The vector the rotation ends at. TYPE: np . ndarray rotation_axis The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. TYPE: np . ndarray RETURNS DESCRIPTION angle The signed angle of rotation in radians. TYPE: float Source code in src/napari_threedee/utils/geometry.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def signed_angle_between_vectors ( vector_0 , vector_1 , rotation_axis : np . ndarray ) -> float : \"\"\" Returns the angle in radians between vectors 'v1' and 'v2'. Parameters ---------- vector_0 : np.ndarray The vector to start the rotation at. vector_1 : np.ndarray The vector the rotation ends at. rotation_axis : np.ndarray The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. Returns ------- angle : float The signed angle of rotation in radians. \"\"\" unit_vector_0 = vector_0 / np . linalg . norm ( vector_0 ) unit_vector_1 = vector_1 / np . linalg . norm ( vector_1 ) unsigned_angle = np . arccos ( np . clip ( np . dot ( unit_vector_0 , unit_vector_1 ), - 1.0 , 1.0 )) v3 = np . cross ( unit_vector_0 , unit_vector_1 ) angle_sign = - 1 if np . dot ( v3 , rotation_axis ) < 0 else 1 return angle_sign * unsigned_angle rotation_matrix_around_vector_3d ( angle : float , vector : np . ndarray ) -> np . ndarray Create the rotation matrix for a specified angle of rotation around a vector. PARAMETER DESCRIPTION angle The signed angle of rotation in radians. TYPE: float vector : np.ndarray The vector around which to perform the rotation. RETURNS DESCRIPTION rotation_matrix (3, 3) rotation matrix for the specified rotation. TYPE: np . ndarray Source code in src/napari_threedee/utils/geometry.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def rotation_matrix_around_vector_3d ( angle : float , vector : np . ndarray ) -> np . ndarray : \"\"\"Create the rotation matrix for a specified angle of rotation around a vector. Parameters ---------- angle : float The signed angle of rotation in radians. vector : np.ndarray The vector around which to perform the rotation. Returns ------- rotation_matrix : np.ndarray (3, 3) rotation matrix for the specified rotation. \"\"\" vector_u = vector / np . linalg . norm ( vector ) u_0 = vector_u [ 0 ] u_1 = vector_u [ 1 ] u_2 = vector_u [ 2 ] cos_term = 1 - np . cos ( angle ) sine_term = np . sin ( angle ) rotation_matrix = np . zeros (( 3 , 3 )) rotation_matrix [ 0 , 0 ] = np . cos ( angle ) + ( u_0 ** 2 ) * cos_term rotation_matrix [ 0 , 1 ] = ( u_0 * u_1 * cos_term ) - u_2 * sine_term rotation_matrix [ 0 , 2 ] = ( u_0 * u_2 * cos_term ) + u_1 * sine_term rotation_matrix [ 1 , 0 ] = ( u_1 * u_0 * cos_term ) + u_2 * sine_term rotation_matrix [ 1 , 1 ] = np . cos ( angle ) + ( u_1 ** 2 ) * cos_term rotation_matrix [ 1 , 2 ] = ( u_1 * u_2 * cos_term ) - u_0 * sine_term rotation_matrix [ 2 , 0 ] = ( u_0 * u_2 * cos_term ) - u_1 * sine_term rotation_matrix [ 2 , 1 ] = u_1 * u_2 * cos_term + u_0 * sine_term rotation_matrix [ 2 , 2 ] = np . cos ( angle ) + ( u_2 ** 2 ) * cos_term return rotation_matrix point_in_bounding_box ( point : np . ndarray , bounding_box : np . ndarray ) -> bool Determine whether an nD point is inside an nD bounding box. PARAMETER DESCRIPTION point (n,) array containing nD point coordinates to check. TYPE: np . ndarray bounding_box (2, n) array containing the min and max of the nD bounding box. As returned by Layer._extent_data . TYPE: np . ndarray Source code in src/napari_threedee/utils/geometry.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def point_in_bounding_box ( point : np . ndarray , bounding_box : np . ndarray ) -> bool : \"\"\"Determine whether an nD point is inside an nD bounding box. Parameters ---------- point : np.ndarray (n,) array containing nD point coordinates to check. bounding_box : np.ndarray (2, n) array containing the min and max of the nD bounding box. As returned by `Layer._extent_data`. \"\"\" if np . all ( point > bounding_box [ 0 ]) and np . all ( point < bounding_box [ 1 ]): return True return False","title":"Geometry utilities"},{"location":"API/geometry_utilities/#geometry-utilities","text":"","title":"Geometry utilities"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry","text":"","title":"geometry"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.signed_angle_between_vectors","text":"Returns the angle in radians between vectors 'v1' and 'v2'. PARAMETER DESCRIPTION vector_0 The vector to start the rotation at. TYPE: np . ndarray vector_1 The vector the rotation ends at. TYPE: np . ndarray rotation_axis The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. TYPE: np . ndarray RETURNS DESCRIPTION angle The signed angle of rotation in radians. TYPE: float Source code in src/napari_threedee/utils/geometry.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def signed_angle_between_vectors ( vector_0 , vector_1 , rotation_axis : np . ndarray ) -> float : \"\"\" Returns the angle in radians between vectors 'v1' and 'v2'. Parameters ---------- vector_0 : np.ndarray The vector to start the rotation at. vector_1 : np.ndarray The vector the rotation ends at. rotation_axis : np.ndarray The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. Returns ------- angle : float The signed angle of rotation in radians. \"\"\" unit_vector_0 = vector_0 / np . linalg . norm ( vector_0 ) unit_vector_1 = vector_1 / np . linalg . norm ( vector_1 ) unsigned_angle = np . arccos ( np . clip ( np . dot ( unit_vector_0 , unit_vector_1 ), - 1.0 , 1.0 )) v3 = np . cross ( unit_vector_0 , unit_vector_1 ) angle_sign = - 1 if np . dot ( v3 , rotation_axis ) < 0 else 1 return angle_sign * unsigned_angle","title":"signed_angle_between_vectors()"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.rotation_matrix_around_vector_3d","text":"Create the rotation matrix for a specified angle of rotation around a vector. PARAMETER DESCRIPTION angle The signed angle of rotation in radians. TYPE: float vector : np.ndarray The vector around which to perform the rotation. RETURNS DESCRIPTION rotation_matrix (3, 3) rotation matrix for the specified rotation. TYPE: np . ndarray Source code in src/napari_threedee/utils/geometry.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def rotation_matrix_around_vector_3d ( angle : float , vector : np . ndarray ) -> np . ndarray : \"\"\"Create the rotation matrix for a specified angle of rotation around a vector. Parameters ---------- angle : float The signed angle of rotation in radians. vector : np.ndarray The vector around which to perform the rotation. Returns ------- rotation_matrix : np.ndarray (3, 3) rotation matrix for the specified rotation. \"\"\" vector_u = vector / np . linalg . norm ( vector ) u_0 = vector_u [ 0 ] u_1 = vector_u [ 1 ] u_2 = vector_u [ 2 ] cos_term = 1 - np . cos ( angle ) sine_term = np . sin ( angle ) rotation_matrix = np . zeros (( 3 , 3 )) rotation_matrix [ 0 , 0 ] = np . cos ( angle ) + ( u_0 ** 2 ) * cos_term rotation_matrix [ 0 , 1 ] = ( u_0 * u_1 * cos_term ) - u_2 * sine_term rotation_matrix [ 0 , 2 ] = ( u_0 * u_2 * cos_term ) + u_1 * sine_term rotation_matrix [ 1 , 0 ] = ( u_1 * u_0 * cos_term ) + u_2 * sine_term rotation_matrix [ 1 , 1 ] = np . cos ( angle ) + ( u_1 ** 2 ) * cos_term rotation_matrix [ 1 , 2 ] = ( u_1 * u_2 * cos_term ) - u_0 * sine_term rotation_matrix [ 2 , 0 ] = ( u_0 * u_2 * cos_term ) - u_1 * sine_term rotation_matrix [ 2 , 1 ] = u_1 * u_2 * cos_term + u_0 * sine_term rotation_matrix [ 2 , 2 ] = np . cos ( angle ) + ( u_2 ** 2 ) * cos_term return rotation_matrix","title":"rotation_matrix_around_vector_3d()"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.point_in_bounding_box","text":"Determine whether an nD point is inside an nD bounding box. PARAMETER DESCRIPTION point (n,) array containing nD point coordinates to check. TYPE: np . ndarray bounding_box (2, n) array containing the min and max of the nD bounding box. As returned by Layer._extent_data . TYPE: np . ndarray Source code in src/napari_threedee/utils/geometry.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def point_in_bounding_box ( point : np . ndarray , bounding_box : np . ndarray ) -> bool : \"\"\"Determine whether an nD point is inside an nD bounding box. Parameters ---------- point : np.ndarray (n,) array containing nD point coordinates to check. bounding_box : np.ndarray (2, n) array containing the min and max of the nD bounding box. As returned by `Layer._extent_data`. \"\"\" if np . all ( point > bounding_box [ 0 ]) and np . all ( point < bounding_box [ 1 ]): return True return False","title":"point_in_bounding_box()"},{"location":"API/napari_utilities/","text":"napari utilities napari_threedee.utils.napari_utils get_napari_visual ( viewer , layer ) Get the visual class for a given layer PARAMETER DESCRIPTION viewer The napari viewer object layer The napari layer object for which to find the visual. RETURNS DESCRIPTION visual The napari visual class for the layer. Source code in src/napari_threedee/utils/napari_utils.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get_napari_visual ( viewer , layer ): \"\"\"Get the visual class for a given layer Parameters ---------- viewer The napari viewer object layer The napari layer object for which to find the visual. Returns ------- visual The napari visual class for the layer. \"\"\" visual = viewer . window . _qt_window . _qt_viewer . layer_to_visual [ layer ] return visual get_mouse_position_in_displayed_dimensions ( event ) -> np . ndarray Get the position under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event The mouse event. RETURNS DESCRIPTION click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in src/napari_threedee/utils/napari_utils.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_mouse_position_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the position under the mouse in scene (displayed world) coordinates. Parameters ---------- event The mouse event. Returns ------- click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position return np . asarray ( click_position_world )[ list ( event . dims_displayed )] get_view_direction_in_displayed_dimensions ( event ) -> np . ndarray Get the view direction under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event napari mouse event. Source code in src/napari_threedee/utils/napari_utils.py 108 109 110 111 112 113 114 115 116 117 def get_view_direction_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the view direction under the mouse in scene (displayed world) coordinates. Parameters ---------- event: Event napari mouse event. \"\"\" view_direction_world = event . view_direction return np . asarray ( view_direction_world )[ list ( event . dims_displayed )] get_mouse_position_in_displayed_layer_data_coordinates ( layer , event ) -> Tuple [ np . ndarray , np . ndarray ] Get the mouse click position and direction in layer data displayed coordinates. PARAMETER DESCRIPTION layer The layer to convert the coordinates to. TYPE: napari . layers . Layer event The mouse event. RETURNS DESCRIPTION click_position_data_3d The click position in displayed data coordinates. TYPE: np . ndarray click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in src/napari_threedee/utils/napari_utils.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def get_mouse_position_in_displayed_layer_data_coordinates ( layer , event ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Get the mouse click position and direction in layer data displayed coordinates. Parameters ---------- layer : napari.layers.Layer The layer to convert the coordinates to. event The mouse event. Returns ------- click_position_data_3d : np.ndarray The click position in displayed data coordinates. click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position click_position_data_3d = np . asarray ( layer . _world_to_displayed_data ( click_position_world , event . dims_displayed ) ) click_dir_data_3d = np . asarray ( layer . _world_to_displayed_data_ray ( event . view_direction , event . dims_displayed ) ) return click_position_data_3d , click_dir_data_3d","title":"napari utilities"},{"location":"API/napari_utilities/#napari-utilities","text":"","title":"napari utilities"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils","text":"","title":"napari_utils"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_napari_visual","text":"Get the visual class for a given layer PARAMETER DESCRIPTION viewer The napari viewer object layer The napari layer object for which to find the visual. RETURNS DESCRIPTION visual The napari visual class for the layer. Source code in src/napari_threedee/utils/napari_utils.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get_napari_visual ( viewer , layer ): \"\"\"Get the visual class for a given layer Parameters ---------- viewer The napari viewer object layer The napari layer object for which to find the visual. Returns ------- visual The napari visual class for the layer. \"\"\" visual = viewer . window . _qt_window . _qt_viewer . layer_to_visual [ layer ] return visual","title":"get_napari_visual()"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_dimensions","text":"Get the position under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event The mouse event. RETURNS DESCRIPTION click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in src/napari_threedee/utils/napari_utils.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_mouse_position_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the position under the mouse in scene (displayed world) coordinates. Parameters ---------- event The mouse event. Returns ------- click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position return np . asarray ( click_position_world )[ list ( event . dims_displayed )]","title":"get_mouse_position_in_displayed_dimensions()"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_view_direction_in_displayed_dimensions","text":"Get the view direction under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event napari mouse event. Source code in src/napari_threedee/utils/napari_utils.py 108 109 110 111 112 113 114 115 116 117 def get_view_direction_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the view direction under the mouse in scene (displayed world) coordinates. Parameters ---------- event: Event napari mouse event. \"\"\" view_direction_world = event . view_direction return np . asarray ( view_direction_world )[ list ( event . dims_displayed )]","title":"get_view_direction_in_displayed_dimensions()"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_layer_data_coordinates","text":"Get the mouse click position and direction in layer data displayed coordinates. PARAMETER DESCRIPTION layer The layer to convert the coordinates to. TYPE: napari . layers . Layer event The mouse event. RETURNS DESCRIPTION click_position_data_3d The click position in displayed data coordinates. TYPE: np . ndarray click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in src/napari_threedee/utils/napari_utils.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def get_mouse_position_in_displayed_layer_data_coordinates ( layer , event ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Get the mouse click position and direction in layer data displayed coordinates. Parameters ---------- layer : napari.layers.Layer The layer to convert the coordinates to. event The mouse event. Returns ------- click_position_data_3d : np.ndarray The click position in displayed data coordinates. click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position click_position_data_3d = np . asarray ( layer . _world_to_displayed_data ( click_position_world , event . dims_displayed ) ) click_dir_data_3d = np . asarray ( layer . _world_to_displayed_data_ray ( event . view_direction , event . dims_displayed ) ) return click_position_data_3d , click_dir_data_3d","title":"get_mouse_position_in_displayed_layer_data_coordinates()"},{"location":"API/selection_utilities/","text":"Selection utilities napari_threedee.utils.selection_utils distance_between_point_and_line_segment_2d ( p , p1 , p2 ) Calculate the distance between a point p and a line segment p1, p2 Source code in src/napari_threedee/utils/selection_utils.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def distance_between_point_and_line_segment_2d ( p , p1 , p2 ): \"\"\"Calculate the distance between a point p and a line segment p1, p2 \"\"\" x0 = p [ 0 ] y0 = p [ 1 ] x1 = p1 [ 0 ] y1 = p1 [ 1 ] x2 = p2 [ 0 ] y2 = p2 [ 1 ] numerator = np . linalg . norm (( x2 - x1 ) * ( y1 - y0 ) - ( x1 - x0 ) * ( y2 - y1 )) denominator = np . sqrt (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) return numerator / denominator select_triangle_from_click ( click_point : np . ndarray , view_direction : np . ndarray , triangles : np . ndarray ) Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. PARAMETER DESCRIPTION click_point (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. TYPE: np . ndarray view_direction (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. TYPE: np . ndarray triangles (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. TYPE: np . ndarray RETURNS DESCRIPTION in_triangles (n,) boolean array that is True of the ray intersects the triangle TYPE: np . ndarray Source code in src/napari_threedee/utils/selection_utils.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def select_triangle_from_click ( click_point : np . ndarray , view_direction : np . ndarray , triangles : np . ndarray ): \"\"\"Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. Parameters ---------- click_point : np.ndarray (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. view_direction : np.ndarray (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. triangles : np.ndarray (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. Returns ------- in_triangles : np.ndarray (n,) boolean array that is True of the ray intersects the triangle \"\"\" vertices = triangles . reshape (( - 1 , triangles . shape [ 2 ])) # project the vertices of the bound region on to the view plane vertices_plane , signed_distance_to_plane = project_points_onto_plane ( points = vertices , plane_point = click_point , plane_normal = view_direction ) # rotate the plane to make the triangles 2D rotation_matrix = rotation_matrix_from_vectors_3d ( view_direction , [ 0 , 0 , 1 ]) rotated_vertices = vertices_plane @ rotation_matrix . T rotated_vertices_2d = rotated_vertices [:, : 2 ] rotated_triangles_2d = rotated_vertices_2d . reshape ( - 1 , 3 , 2 ) line_pos_2D = rotation_matrix . dot ( click_point )[: 2 ] candidate_matches = inside_triangles ( rotated_triangles_2d - line_pos_2D ) candidate_match_indices = np . argwhere ( candidate_matches ) n_matches = len ( candidate_match_indices ) if n_matches == 0 : triangle_index = None elif n_matches == 1 : triangle_index = candidate_match_indices [ 0 ] else : potential_match_distances = signed_distance_to_plane [ candidate_match_indices ] triangle_index = candidate_match_indices [ np . argmin ( potential_match_distances )] return triangle_index select_sphere_from_click ( click_point : np . ndarray , view_direction : np . ndarray , sphere_centroids : np . ndarray , sphere_diameter : float ) -> Optional [ int ] Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. PARAMETER DESCRIPTION click_point The point where the click ray originates. TYPE: np . ndarray view_direction The unit vector pointing in the direction the viewer is looking. TYPE: np . ndarray sphere_centroids The (n, 3) array of center points for the n points. TYPE: np . ndarray sphere_diameter The diameter of all spheres. Must the same diameter for all spheres. TYPE: float RETURNS DESCRIPTION selection The index for the sphere that was intersected. Returns None if no spheres are intersected. TYPE: Optional [ int ] Source code in src/napari_threedee/utils/selection_utils.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def select_sphere_from_click ( click_point : np . ndarray , view_direction : np . ndarray , sphere_centroids : np . ndarray , sphere_diameter : float ) -> Optional [ int ]: \"\"\"Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. Parameters ---------- click_point : np.ndarray The point where the click ray originates. view_direction : np.ndarray The unit vector pointing in the direction the viewer is looking. sphere_centroids : np.ndarray The (n, 3) array of center points for the n points. sphere_diameter : float The diameter of all spheres. Must the same diameter for all spheres. Returns ------- selection : Optional[int] The index for the sphere that was intersected. Returns None if no spheres are intersected. \"\"\" # project the in view points onto the camera plane projected_points , projection_distances = project_points_onto_plane ( points = sphere_centroids , plane_point = click_point , plane_normal = view_direction , ) # rotate points and plane to be axis aligned with normal [0, 0, 1] rotated_points , rotation_matrix = rotate_points ( points = projected_points , current_plane_normal = view_direction , new_plane_normal = [ 0 , 0 , 1 ], ) rotated_click_point = np . dot ( rotation_matrix , click_point ) # find the points the click intersects n_spheres = len ( sphere_centroids ) handle_sizes = np . tile ( sphere_diameter , ( n_spheres , 1 )) distances = abs ( rotated_points [:, : 2 ] - rotated_click_point [: 2 ]) # the -1 accounts for the edge width in_slice_matches = np . all ( distances <= ( handle_sizes - 1 / 2 ) - 1.5 , axis = 1 , ) indices = np . where ( in_slice_matches )[ 0 ] if len ( indices ) > 0 : # find the point that is most in the foreground candidate_point_distances = projection_distances [ indices ] min_distance_index = np . argmin ( candidate_point_distances ) selection = indices [ min_distance_index ] else : selection = None return selection","title":"Selection utilities"},{"location":"API/selection_utilities/#selection-utilities","text":"","title":"Selection utilities"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils","text":"","title":"selection_utils"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.distance_between_point_and_line_segment_2d","text":"Calculate the distance between a point p and a line segment p1, p2 Source code in src/napari_threedee/utils/selection_utils.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def distance_between_point_and_line_segment_2d ( p , p1 , p2 ): \"\"\"Calculate the distance between a point p and a line segment p1, p2 \"\"\" x0 = p [ 0 ] y0 = p [ 1 ] x1 = p1 [ 0 ] y1 = p1 [ 1 ] x2 = p2 [ 0 ] y2 = p2 [ 1 ] numerator = np . linalg . norm (( x2 - x1 ) * ( y1 - y0 ) - ( x1 - x0 ) * ( y2 - y1 )) denominator = np . sqrt (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) return numerator / denominator","title":"distance_between_point_and_line_segment_2d()"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_triangle_from_click","text":"Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. PARAMETER DESCRIPTION click_point (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. TYPE: np . ndarray view_direction (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. TYPE: np . ndarray triangles (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. TYPE: np . ndarray RETURNS DESCRIPTION in_triangles (n,) boolean array that is True of the ray intersects the triangle TYPE: np . ndarray Source code in src/napari_threedee/utils/selection_utils.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def select_triangle_from_click ( click_point : np . ndarray , view_direction : np . ndarray , triangles : np . ndarray ): \"\"\"Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. Parameters ---------- click_point : np.ndarray (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. view_direction : np.ndarray (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. triangles : np.ndarray (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. Returns ------- in_triangles : np.ndarray (n,) boolean array that is True of the ray intersects the triangle \"\"\" vertices = triangles . reshape (( - 1 , triangles . shape [ 2 ])) # project the vertices of the bound region on to the view plane vertices_plane , signed_distance_to_plane = project_points_onto_plane ( points = vertices , plane_point = click_point , plane_normal = view_direction ) # rotate the plane to make the triangles 2D rotation_matrix = rotation_matrix_from_vectors_3d ( view_direction , [ 0 , 0 , 1 ]) rotated_vertices = vertices_plane @ rotation_matrix . T rotated_vertices_2d = rotated_vertices [:, : 2 ] rotated_triangles_2d = rotated_vertices_2d . reshape ( - 1 , 3 , 2 ) line_pos_2D = rotation_matrix . dot ( click_point )[: 2 ] candidate_matches = inside_triangles ( rotated_triangles_2d - line_pos_2D ) candidate_match_indices = np . argwhere ( candidate_matches ) n_matches = len ( candidate_match_indices ) if n_matches == 0 : triangle_index = None elif n_matches == 1 : triangle_index = candidate_match_indices [ 0 ] else : potential_match_distances = signed_distance_to_plane [ candidate_match_indices ] triangle_index = candidate_match_indices [ np . argmin ( potential_match_distances )] return triangle_index","title":"select_triangle_from_click()"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_sphere_from_click","text":"Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. PARAMETER DESCRIPTION click_point The point where the click ray originates. TYPE: np . ndarray view_direction The unit vector pointing in the direction the viewer is looking. TYPE: np . ndarray sphere_centroids The (n, 3) array of center points for the n points. TYPE: np . ndarray sphere_diameter The diameter of all spheres. Must the same diameter for all spheres. TYPE: float RETURNS DESCRIPTION selection The index for the sphere that was intersected. Returns None if no spheres are intersected. TYPE: Optional [ int ] Source code in src/napari_threedee/utils/selection_utils.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def select_sphere_from_click ( click_point : np . ndarray , view_direction : np . ndarray , sphere_centroids : np . ndarray , sphere_diameter : float ) -> Optional [ int ]: \"\"\"Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. Parameters ---------- click_point : np.ndarray The point where the click ray originates. view_direction : np.ndarray The unit vector pointing in the direction the viewer is looking. sphere_centroids : np.ndarray The (n, 3) array of center points for the n points. sphere_diameter : float The diameter of all spheres. Must the same diameter for all spheres. Returns ------- selection : Optional[int] The index for the sphere that was intersected. Returns None if no spheres are intersected. \"\"\" # project the in view points onto the camera plane projected_points , projection_distances = project_points_onto_plane ( points = sphere_centroids , plane_point = click_point , plane_normal = view_direction , ) # rotate points and plane to be axis aligned with normal [0, 0, 1] rotated_points , rotation_matrix = rotate_points ( points = projected_points , current_plane_normal = view_direction , new_plane_normal = [ 0 , 0 , 1 ], ) rotated_click_point = np . dot ( rotation_matrix , click_point ) # find the points the click intersects n_spheres = len ( sphere_centroids ) handle_sizes = np . tile ( sphere_diameter , ( n_spheres , 1 )) distances = abs ( rotated_points [:, : 2 ] - rotated_click_point [: 2 ]) # the -1 accounts for the edge width in_slice_matches = np . all ( distances <= ( handle_sizes - 1 / 2 ) - 1.5 , axis = 1 , ) indices = np . where ( in_slice_matches )[ 0 ] if len ( indices ) > 0 : # find the point that is most in the foreground candidate_point_distances = projection_distances [ indices ] min_distance_index = np . argmin ( candidate_point_distances ) selection = indices [ min_distance_index ] else : selection = None return selection","title":"select_sphere_from_click()"},{"location":"annotations/io/","text":"Input/Output Annotation layers can be serialized to disk as n3d files. n3d files are zarr files . napari-threedee napari-threedee implements readers and writers for n3d files. Python n3d files can be opened in Python with the zarr library. import zarr n3d_data = zarr . load ( 'annotation.n3d' ) These objects contain some attributes allowing them to be correctly interpreted by napari-threedee . The attribute annotation_type maps to a specific reader function napari-threedee will use to load the data. n3d_data . attrs [ \"annotation_type\" ] Out [ 2 ]: 'spline' Other programming languages For working with n3d ( zarr ) files in other languages, please look at the zarr implementations repository .","title":"Input/Output"},{"location":"annotations/io/#inputoutput","text":"Annotation layers can be serialized to disk as n3d files. n3d files are zarr files .","title":"Input/Output"},{"location":"annotations/io/#napari-threedee","text":"napari-threedee implements readers and writers for n3d files.","title":"napari-threedee"},{"location":"annotations/io/#python","text":"n3d files can be opened in Python with the zarr library. import zarr n3d_data = zarr . load ( 'annotation.n3d' ) These objects contain some attributes allowing them to be correctly interpreted by napari-threedee . The attribute annotation_type maps to a specific reader function napari-threedee will use to load the data. n3d_data . attrs [ \"annotation_type\" ] Out [ 2 ]: 'spline'","title":"Python"},{"location":"annotations/io/#other-programming-languages","text":"For working with n3d ( zarr ) files in other languages, please look at the zarr implementations repository .","title":"Other programming languages"},{"location":"annotations/point_spec/","text":"Point Specification Layer Specification Point annotations are stored on a napari Points layer . Points.data is an (n, d) array of n d-dimensional points. Points.metadata[\"n3d_metadata\"] is a dictionary with the following key/value pairs annotation_type : point Zarr Array Specification The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'points.n3d' ) n3d is an (n, d) zarr.core.Array containing the points n3d.attrs[\"annotation_type\"] is \"sphere\"","title":"Point Specification"},{"location":"annotations/point_spec/#point-specification","text":"","title":"Point Specification"},{"location":"annotations/point_spec/#layer-specification","text":"Point annotations are stored on a napari Points layer . Points.data is an (n, d) array of n d-dimensional points. Points.metadata[\"n3d_metadata\"] is a dictionary with the following key/value pairs annotation_type : point","title":"Layer Specification"},{"location":"annotations/point_spec/#zarr-array-specification","text":"The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'points.n3d' ) n3d is an (n, d) zarr.core.Array containing the points n3d.attrs[\"annotation_type\"] is \"sphere\"","title":"Zarr Array Specification"},{"location":"annotations/specifications/","text":"Overview Annotations made using the annotators from napari-threedee are stored on a single layer. This layer will match a specification for a given annotation type. Per-point attributes will be stored in the layer features table. Other metadata will be stored in the layer metadata as a dictionary under the \"n3d_metadata\" key. Specifications spline specification (points layer) sphere specification (points layer) point specification (points layer)","title":"Overview"},{"location":"annotations/specifications/#overview","text":"Annotations made using the annotators from napari-threedee are stored on a single layer. This layer will match a specification for a given annotation type. Per-point attributes will be stored in the layer features table. Other metadata will be stored in the layer metadata as a dictionary under the \"n3d_metadata\" key.","title":"Overview"},{"location":"annotations/specifications/#specifications","text":"spline specification (points layer) sphere specification (points layer) point specification (points layer)","title":"Specifications"},{"location":"annotations/sphere_spec/","text":"Sphere Specification Layer Specification Sphere annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain column called sphere_id , an integer id for each sphere. radius , a radius for each sphere. Points.metadata[\"n3d_metadata\"] is a dictionary with the following key/value pairs annotation_type : sphere Zarr Array Specification The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'sphere.n3d' ) n3d is an (n, d) zarr.core.Array containing the center of each sphere n3d.attrs[\"annotation_type\"] is \"sphere\" n3d.attrs[\"sphere_id\"] is an (n, ) array containing a unique id for each sphere n3d.attrs[\"radius\"] is an (n, ) array containing the radius for each sphere","title":"Sphere Specification"},{"location":"annotations/sphere_spec/#sphere-specification","text":"","title":"Sphere Specification"},{"location":"annotations/sphere_spec/#layer-specification","text":"Sphere annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain column called sphere_id , an integer id for each sphere. radius , a radius for each sphere. Points.metadata[\"n3d_metadata\"] is a dictionary with the following key/value pairs annotation_type : sphere","title":"Layer Specification"},{"location":"annotations/sphere_spec/#zarr-array-specification","text":"The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'sphere.n3d' ) n3d is an (n, d) zarr.core.Array containing the center of each sphere n3d.attrs[\"annotation_type\"] is \"sphere\" n3d.attrs[\"sphere_id\"] is an (n, ) array containing a unique id for each sphere n3d.attrs[\"radius\"] is an (n, ) array containing the radius for each sphere","title":"Zarr Array Specification"},{"location":"annotations/spline_spec/","text":"Spline Specification Layer Specification Spline annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain a column called spline_id , an integer id for each point. Points.metadata[\"n3d_metadata\"] is a dictionary with the following key/value pairs annotation_type : spline Zarr Array Specification The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'spline.n3d' ) n3d is an (n, d) zarr.core.Array n3d.attrs[\"annotation_type\"] is \"spline\" n3d.attrs[\"spline_id\"] is an (n, ) array containing the spline id of each point","title":"Spline Specification"},{"location":"annotations/spline_spec/#spline-specification","text":"","title":"Spline Specification"},{"location":"annotations/spline_spec/#layer-specification","text":"Spline annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain a column called spline_id , an integer id for each point. Points.metadata[\"n3d_metadata\"] is a dictionary with the following key/value pairs annotation_type : spline","title":"Layer Specification"},{"location":"annotations/spline_spec/#zarr-array-specification","text":"The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'spline.n3d' ) n3d is an (n, d) zarr.core.Array n3d.attrs[\"annotation_type\"] is \"spline\" n3d.attrs[\"spline_id\"] is an (n, ) array containing the spline id of each point","title":"Zarr Array Specification"},{"location":"dev_guides/core_concepts/","text":"Core concepts napari-threedee provides reusable components (called threedee objects ) which - enable custom 3D interactive functionality - simplify the development of workflows with 3D interactivity How to use napari-threedee napari-threedee is designed to be used both as a napari plugin and as a library . When used as a plugin , a set of widgets provide custom 3D manipulation and annotation tools in napari. In this case, users need not delve into the code. For those who want to integrate custom 3D interactivity into their application, napari-threedee can also be used as a library . In this case, users can - integrate existing functionality into their applications - develop new custom functionality more easily threedee objects threedee objects can be split into two categories, manipulators and annotators . They can be activated and deactivated as required. Manipulators A Manipulator is an object in the scene which allows us to position something. It is a combination of translators and rotators . Clicking and dragging a translator will move the manipulator in the direction of the translator. Clicking and dragging a rotator will rotate the object. Manipulators can be used to modify other objects by providing callbacks which will be run before, during and after an interaction with the manipulator. For more details see manipulators Annotators An Annotator allows for a custom 3D data annotation mode in napari. This is particularly useful for orchestrating annotation behaviour which depends on the state of multiple layers (e.g. adding points on planes). Automatic widget generation A dock widget can be generated automatically for any threedee object by subclassing QtThreeDeeWidgetBase and providing the new threedee object as a model. class QtRenderPlaneManipulatorWidget ( QtThreeDeeWidgetBase ): def __init__ ( self , viewer : napari . Viewer , * args , ** kwargs ): super () . __init__ ( model = RenderPlaneManipulator , viewer = viewer , * args , ** kwargs )","title":"Core concepts"},{"location":"dev_guides/core_concepts/#core-concepts","text":"napari-threedee provides reusable components (called threedee objects ) which - enable custom 3D interactive functionality - simplify the development of workflows with 3D interactivity","title":"Core concepts"},{"location":"dev_guides/core_concepts/#how-to-use-napari-threedee","text":"napari-threedee is designed to be used both as a napari plugin and as a library . When used as a plugin , a set of widgets provide custom 3D manipulation and annotation tools in napari. In this case, users need not delve into the code. For those who want to integrate custom 3D interactivity into their application, napari-threedee can also be used as a library . In this case, users can - integrate existing functionality into their applications - develop new custom functionality more easily","title":"How to use napari-threedee"},{"location":"dev_guides/core_concepts/#threedee-objects","text":"threedee objects can be split into two categories, manipulators and annotators . They can be activated and deactivated as required.","title":"threedee objects"},{"location":"dev_guides/core_concepts/#manipulators","text":"A Manipulator is an object in the scene which allows us to position something. It is a combination of translators and rotators . Clicking and dragging a translator will move the manipulator in the direction of the translator. Clicking and dragging a rotator will rotate the object. Manipulators can be used to modify other objects by providing callbacks which will be run before, during and after an interaction with the manipulator. For more details see manipulators","title":"Manipulators"},{"location":"dev_guides/core_concepts/#annotators","text":"An Annotator allows for a custom 3D data annotation mode in napari. This is particularly useful for orchestrating annotation behaviour which depends on the state of multiple layers (e.g. adding points on planes).","title":"Annotators"},{"location":"dev_guides/core_concepts/#automatic-widget-generation","text":"A dock widget can be generated automatically for any threedee object by subclassing QtThreeDeeWidgetBase and providing the new threedee object as a model. class QtRenderPlaneManipulatorWidget ( QtThreeDeeWidgetBase ): def __init__ ( self , viewer : napari . Viewer , * args , ** kwargs ): super () . __init__ ( model = RenderPlaneManipulator , viewer = viewer , * args , ** kwargs )","title":"Automatic widget generation"},{"location":"dev_guides/manipulators/","text":"Manipulators Manipulators are UI elements attached to napari layers to aid with positioning and orienting layer data elements being displayed on the canvas. Manipulators can translate and rotate along/around specified axes. Coordinate system The manipulator coordinate system is defined with an affine transformation relative to the layer data coordinate system. The manipulator transformation is defined as a translation and a 3x3 transformation matrix (rotation and scale). The translation is stored in the manipulator.translation property and the transformation is stored in the manipulator. rot_mat property. The rotation is applied before the translation. Translators Translators are the UI element on the manipulator responsible for translating the manipulator. When the user clicks on a translator and drags it, the manipulator is translated by the drag vector component parallel to the translator direction. Translators are defined by unit vectors pointing in the direction of translation. The unit vectors are stored in the _initial_translator_normals property as an (n x 3) numpy array for n translators. One translator will be created for each unit vector in initial_translator_normals . Translator drag callback When a translator is dragged, the following callbacks are executed: _pre_drag() : This is called when the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_translator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the translator drag. _post_drag() : This is called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks. Implementing translators To add translators to a manipulator, the following must be implemented: _initial_translator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_translator() must be implemented. _post_drag() may be implemented. Rotators Rotators are the UI element on the manipulator responsible for rotating the manipulator. When the user clicks on a rotator and drags it, the manipulator is rotated around the normal vector of the rotator. Rotators are defined by unit vectors normal to the rotators. The unit vectors are stored in the _initial_rotators_normals property as an (n x 3) numpy array for n translators. One rotator will be created for each unit vector in initial_rotator_normals . Rotator drag callback When a rotator is dragged, the following callbacks are executed: _pre_drag() :This is called after the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_rotator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the rotator drag. _post_drag() : This is called called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks. Implementing rotators To add rotators to a manipulator, the following must be implemented: _initial_rotator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_rotator() must be implemented. _post_drag() may be implemented. Notes on performance In general, writing data to the GPU is slow compared to drawing the scene. Thus, it is recommended that for best performance, one should move the manipulator in the scene by modifying the transformation rather than modifying the manipulator definitions (i.e., _initial_translator_normals and _rotator_translator_normals )","title":"Manipulators"},{"location":"dev_guides/manipulators/#manipulators","text":"Manipulators are UI elements attached to napari layers to aid with positioning and orienting layer data elements being displayed on the canvas. Manipulators can translate and rotate along/around specified axes.","title":"Manipulators"},{"location":"dev_guides/manipulators/#coordinate-system","text":"The manipulator coordinate system is defined with an affine transformation relative to the layer data coordinate system. The manipulator transformation is defined as a translation and a 3x3 transformation matrix (rotation and scale). The translation is stored in the manipulator.translation property and the transformation is stored in the manipulator. rot_mat property. The rotation is applied before the translation.","title":"Coordinate system"},{"location":"dev_guides/manipulators/#translators","text":"Translators are the UI element on the manipulator responsible for translating the manipulator. When the user clicks on a translator and drags it, the manipulator is translated by the drag vector component parallel to the translator direction. Translators are defined by unit vectors pointing in the direction of translation. The unit vectors are stored in the _initial_translator_normals property as an (n x 3) numpy array for n translators. One translator will be created for each unit vector in initial_translator_normals .","title":"Translators"},{"location":"dev_guides/manipulators/#translator-drag-callback","text":"When a translator is dragged, the following callbacks are executed: _pre_drag() : This is called when the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_translator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the translator drag. _post_drag() : This is called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks.","title":"Translator drag callback"},{"location":"dev_guides/manipulators/#implementing-translators","text":"To add translators to a manipulator, the following must be implemented: _initial_translator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_translator() must be implemented. _post_drag() may be implemented.","title":"Implementing translators"},{"location":"dev_guides/manipulators/#rotators","text":"Rotators are the UI element on the manipulator responsible for rotating the manipulator. When the user clicks on a rotator and drags it, the manipulator is rotated around the normal vector of the rotator. Rotators are defined by unit vectors normal to the rotators. The unit vectors are stored in the _initial_rotators_normals property as an (n x 3) numpy array for n translators. One rotator will be created for each unit vector in initial_rotator_normals .","title":"Rotators"},{"location":"dev_guides/manipulators/#rotator-drag-callback","text":"When a rotator is dragged, the following callbacks are executed: _pre_drag() :This is called after the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_rotator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the rotator drag. _post_drag() : This is called called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks.","title":"Rotator drag callback"},{"location":"dev_guides/manipulators/#implementing-rotators","text":"To add rotators to a manipulator, the following must be implemented: _initial_rotator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_rotator() must be implemented. _post_drag() may be implemented.","title":"Implementing rotators"},{"location":"dev_guides/manipulators/#notes-on-performance","text":"In general, writing data to the GPU is slow compared to drawing the scene. Thus, it is recommended that for best performance, one should move the manipulator in the scene by modifying the transformation rather than modifying the manipulator definitions (i.e., _initial_translator_normals and _rotator_translator_normals )","title":"Notes on performance"},{"location":"generated/gallery/","text":"Gallery for napari-threedee Gallery of examples built with napari-threedee. Library examples Examples where napari-threedee is used as a library. Layer manipulator (library) Camera spline (library) Render plane manipulator (library) Mesh headlight (library) Surface annotator (library) Point annotator (library) Path point annotator (library) Sphere annotator (library) Plugin examples Examples where napari-threedee is used as a napari plugin. Points manipulator (plugin) Mesh headlight (plugin) Surface annotator example (plugin) Render plane manipulator (plugin) Layer manipulator (plugin) Camera spline (plugin) Plane point annotator (plugin) Spline annotator (plugin) Sphere annotator (plugin) Path point annotator (plugin) Download all examples in Python source code: gallery_python.zip Download all examples in Jupyter notebooks: gallery_jupyter.zip Gallery generated by mkdocs-gallery","title":"Examples gallery"},{"location":"generated/gallery/#gallery-for-napari-threedee","text":"Gallery of examples built with napari-threedee.","title":"Gallery for napari-threedee"},{"location":"generated/gallery/#library-examples","text":"Examples where napari-threedee is used as a library. Layer manipulator (library) Camera spline (library) Render plane manipulator (library) Mesh headlight (library) Surface annotator (library) Point annotator (library) Path point annotator (library) Sphere annotator (library)","title":"Library examples"},{"location":"generated/gallery/#plugin-examples","text":"Examples where napari-threedee is used as a napari plugin. Points manipulator (plugin) Mesh headlight (plugin) Surface annotator example (plugin) Render plane manipulator (plugin) Layer manipulator (plugin) Camera spline (plugin) Plane point annotator (plugin) Spline annotator (plugin) Sphere annotator (plugin) Path point annotator (plugin) Download all examples in Python source code: gallery_python.zip Download all examples in Jupyter notebooks: gallery_jupyter.zip Gallery generated by mkdocs-gallery","title":"Plugin examples"},{"location":"generated/gallery/library/camera_spline_library/","text":"Note Click here to download the full example code Camera spline (library) An example controlling the camera spline, using napari-threedee as a library. import napari import skimage from napari_threedee.visualization._qt.qt_camera_spline import QtCameraSpline viewer = napari . Viewer ( ndisplay = 3 ) blobs = skimage . data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 4 ) . astype ( float ) plane_parameters_z = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } viewer . add_image ( blobs , name = 'orange plane' , rendering = 'average' , colormap = 'bop orange' , depiction = 'plane' , plane = plane_parameters_z ) camera_spline = QtCameraSpline ( viewer = viewer ) viewer . window . add_dock_widget ( camera_spline ) napari . run () Total running time of the script: ( 0 minutes 2.359 seconds) Download Python source code: camera_spline_library.py Download Jupyter notebook: camera_spline_library.ipynb Gallery generated by mkdocs-gallery","title":"Camera spline (library)"},{"location":"generated/gallery/library/camera_spline_library/#camera-spline-library","text":"An example controlling the camera spline, using napari-threedee as a library. import napari import skimage from napari_threedee.visualization._qt.qt_camera_spline import QtCameraSpline viewer = napari . Viewer ( ndisplay = 3 ) blobs = skimage . data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 4 ) . astype ( float ) plane_parameters_z = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } viewer . add_image ( blobs , name = 'orange plane' , rendering = 'average' , colormap = 'bop orange' , depiction = 'plane' , plane = plane_parameters_z ) camera_spline = QtCameraSpline ( viewer = viewer ) viewer . window . add_dock_widget ( camera_spline ) napari . run () Total running time of the script: ( 0 minutes 2.359 seconds) Download Python source code: camera_spline_library.py Download Jupyter notebook: camera_spline_library.ipynb Gallery generated by mkdocs-gallery","title":"Camera spline (library)"},{"location":"generated/gallery/library/layer_manipulator_library/","text":"Note Click here to download the full example code Layer manipulator (library) An example controlling the layer manipulator, using napari-threedee as a library. import napari import numpy as np from napari_threedee.manipulators._qt import QtLayerManipulatorWidget data = np . random . random (( 100 , 100 , 100 )) viewer = napari . view_image ( data ) image_layer = viewer . layers [ 0 ] viewer . dims . ndisplay = 3 widget = QtLayerManipulatorWidget ( viewer ) viewer . window . add_dock_widget ( widget ) napari . run () Total running time of the script: ( 0 minutes 6.259 seconds) Download Python source code: layer_manipulator_library.py Download Jupyter notebook: layer_manipulator_library.ipynb Gallery generated by mkdocs-gallery","title":"Layer manipulator (library)"},{"location":"generated/gallery/library/layer_manipulator_library/#layer-manipulator-library","text":"An example controlling the layer manipulator, using napari-threedee as a library. import napari import numpy as np from napari_threedee.manipulators._qt import QtLayerManipulatorWidget data = np . random . random (( 100 , 100 , 100 )) viewer = napari . view_image ( data ) image_layer = viewer . layers [ 0 ] viewer . dims . ndisplay = 3 widget = QtLayerManipulatorWidget ( viewer ) viewer . window . add_dock_widget ( widget ) napari . run () Total running time of the script: ( 0 minutes 6.259 seconds) Download Python source code: layer_manipulator_library.py Download Jupyter notebook: layer_manipulator_library.ipynb Gallery generated by mkdocs-gallery","title":"Layer manipulator (library)"},{"location":"generated/gallery/library/mesh_headlight_library/","text":"Note Click here to download the full example code Mesh headlight (library) An example controlling the mesh headlight, using napari-threedee as a library. Out: Downloading data from https://raw.githubusercontent.com/vispy/demo-data/main/orig/triceratops.obj.gz ( 141 kB ) [ .................. ] 45 .52059 | downloading [ .................................... ] 91 .04119 / downloading [ ........................................ ] 100 .00000 - downloading File saved as /home/runner/.vispy/data/orig/triceratops.obj.gz. import napari import numpy as np from vispy.io import load_data_file , read_mesh from napari_threedee.visualization._qt.qt_lighting_control import QtLightingControlWidget # Fetch datasets - this will download dataset if datasets are not found vertices , faces , _ , _ = read_mesh ( load_data_file ( 'orig/triceratops.obj.gz' )) # put the mesh right side up, scale it up (napari#3477) and fix faces handedness vertices *= - 100 faces = faces [:, :: - 1 ] vertex_values = np . ones (( len ( vertices ),)) # create an empty viewer viewer = napari . Viewer ( ndisplay = 3 ) # add the mesh viewer . add_surface (( vertices , faces , vertex_values ), name = 'triceratops' ) lighting_control_widget = QtLightingControlWidget ( viewer = viewer ) viewer . window . add_dock_widget ( widget = lighting_control_widget ) napari . run () Total running time of the script: ( 0 minutes 1.010 seconds) Download Python source code: mesh_headlight_library.py Download Jupyter notebook: mesh_headlight_library.ipynb Gallery generated by mkdocs-gallery","title":"Mesh headlight (library)"},{"location":"generated/gallery/library/mesh_headlight_library/#mesh-headlight-library","text":"An example controlling the mesh headlight, using napari-threedee as a library. Out: Downloading data from https://raw.githubusercontent.com/vispy/demo-data/main/orig/triceratops.obj.gz ( 141 kB ) [ .................. ] 45 .52059 | downloading [ .................................... ] 91 .04119 / downloading [ ........................................ ] 100 .00000 - downloading File saved as /home/runner/.vispy/data/orig/triceratops.obj.gz. import napari import numpy as np from vispy.io import load_data_file , read_mesh from napari_threedee.visualization._qt.qt_lighting_control import QtLightingControlWidget # Fetch datasets - this will download dataset if datasets are not found vertices , faces , _ , _ = read_mesh ( load_data_file ( 'orig/triceratops.obj.gz' )) # put the mesh right side up, scale it up (napari#3477) and fix faces handedness vertices *= - 100 faces = faces [:, :: - 1 ] vertex_values = np . ones (( len ( vertices ),)) # create an empty viewer viewer = napari . Viewer ( ndisplay = 3 ) # add the mesh viewer . add_surface (( vertices , faces , vertex_values ), name = 'triceratops' ) lighting_control_widget = QtLightingControlWidget ( viewer = viewer ) viewer . window . add_dock_widget ( widget = lighting_control_widget ) napari . run () Total running time of the script: ( 0 minutes 1.010 seconds) Download Python source code: mesh_headlight_library.py Download Jupyter notebook: mesh_headlight_library.ipynb Gallery generated by mkdocs-gallery","title":"Mesh headlight (library)"},{"location":"generated/gallery/library/mg_execution_times/","text":"Computation times 00:18.114 total execution time for generated_gallery_library files: +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | layer_manipulator_library (docs/examples/library/layer_manipulator_library.py) | 00:06.259 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | path_annotator_library (docs/examples/library/path_annotator_library.py) | 00:02.852 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | surface_annotator_library (docs/examples/library/surface_annotator_library.py) | 00:02.603 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | camera_spline_library (docs/examples/library/camera_spline_library.py) | 00:02.359 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | point_annotator_library (docs/examples/library/point_annotator_library.py) | 00:01.320 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | mesh_headlight_library (docs/examples/library/mesh_headlight_library.py) | 00:01.010 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | render_plane_manipulator_library (docs/examples/library/render_plane_manipulator_library.py) | 00:00.956 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | sphere_annotator_library (docs/examples/library/sphere_annotator_library.py) | 00:00.755 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+","title":"Computation times"},{"location":"generated/gallery/library/mg_execution_times/#computation-times","text":"00:18.114 total execution time for generated_gallery_library files: +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | layer_manipulator_library (docs/examples/library/layer_manipulator_library.py) | 00:06.259 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | path_annotator_library (docs/examples/library/path_annotator_library.py) | 00:02.852 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | surface_annotator_library (docs/examples/library/surface_annotator_library.py) | 00:02.603 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | camera_spline_library (docs/examples/library/camera_spline_library.py) | 00:02.359 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | point_annotator_library (docs/examples/library/point_annotator_library.py) | 00:01.320 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | mesh_headlight_library (docs/examples/library/mesh_headlight_library.py) | 00:01.010 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | render_plane_manipulator_library (docs/examples/library/render_plane_manipulator_library.py) | 00:00.956 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | sphere_annotator_library (docs/examples/library/sphere_annotator_library.py) | 00:00.755 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+","title":"Computation times"},{"location":"generated/gallery/library/path_annotator_library/","text":"Note Click here to download the full example code Path point annotator (library) An example controlling the path annotator, using napari-threedee as a library. import napari import numpy as np from skimage import data from napari_threedee.annotators import PathAnnotator from napari_threedee.data_models import N3dPaths , N3dPath CREATE_LAYER_FROM_EXISTING_DATA = True # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 4 ) . astype ( float ) # add image layer to viewer (rendering as a plane) image_layer = viewer . add_image ( blobs , name = 'orange plane' , rendering = 'average' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } ) # optionally create an n3d compatible points layer from existing data if CREATE_LAYER_FROM_EXISTING_DATA is True : path = N3dPath ( data = np . random . uniform ( low = 8 , high = 56 , size = ( 10 , 3 ))) points_layer = N3dPaths ( data = [ path ]) . as_layer () # list of N3dPath else : points_layer = None # create the path annotator annotator = PathAnnotator ( viewer = viewer , image_layer = image_layer , points_layer = points_layer , enabled = True , ) # run napari viewer . axes . visible = True viewer . axes . labels = False viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 2.852 seconds) Download Python source code: path_annotator_library.py Download Jupyter notebook: path_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Path point annotator (library)"},{"location":"generated/gallery/library/path_annotator_library/#path-point-annotator-library","text":"An example controlling the path annotator, using napari-threedee as a library. import napari import numpy as np from skimage import data from napari_threedee.annotators import PathAnnotator from napari_threedee.data_models import N3dPaths , N3dPath CREATE_LAYER_FROM_EXISTING_DATA = True # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 4 ) . astype ( float ) # add image layer to viewer (rendering as a plane) image_layer = viewer . add_image ( blobs , name = 'orange plane' , rendering = 'average' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } ) # optionally create an n3d compatible points layer from existing data if CREATE_LAYER_FROM_EXISTING_DATA is True : path = N3dPath ( data = np . random . uniform ( low = 8 , high = 56 , size = ( 10 , 3 ))) points_layer = N3dPaths ( data = [ path ]) . as_layer () # list of N3dPath else : points_layer = None # create the path annotator annotator = PathAnnotator ( viewer = viewer , image_layer = image_layer , points_layer = points_layer , enabled = True , ) # run napari viewer . axes . visible = True viewer . axes . labels = False viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 2.852 seconds) Download Python source code: path_annotator_library.py Download Jupyter notebook: path_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Path point annotator (library)"},{"location":"generated/gallery/library/point_annotator_library/","text":"Note Click here to download the full example code Point annotator (library) An example controlling the point annotator, using napari-threedee as a library. import napari from skimage import data from napari_threedee.annotators import PointAnnotator # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate 3d image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) # add image layer to viewer (rendering as a plane) image_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , }, ) # add points layer to viewer points_layer = viewer . add_points ( data = [], size = 5 , face_color = 'cornflowerblue' , ndim = 3 ) # create the point annotator annotator = PointAnnotator ( viewer = viewer , image_layer = image_layer , points_layer = points_layer , enabled = True , ) # run napari viewer . layers . selection = [ image_layer ] viewer . axes . visible = True viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 1.320 seconds) Download Python source code: point_annotator_library.py Download Jupyter notebook: point_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Point annotator (library)"},{"location":"generated/gallery/library/point_annotator_library/#point-annotator-library","text":"An example controlling the point annotator, using napari-threedee as a library. import napari from skimage import data from napari_threedee.annotators import PointAnnotator # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate 3d image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) # add image layer to viewer (rendering as a plane) image_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , }, ) # add points layer to viewer points_layer = viewer . add_points ( data = [], size = 5 , face_color = 'cornflowerblue' , ndim = 3 ) # create the point annotator annotator = PointAnnotator ( viewer = viewer , image_layer = image_layer , points_layer = points_layer , enabled = True , ) # run napari viewer . layers . selection = [ image_layer ] viewer . axes . visible = True viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 1.320 seconds) Download Python source code: point_annotator_library.py Download Jupyter notebook: point_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Point annotator (library)"},{"location":"generated/gallery/library/render_plane_manipulator_library/","text":"Note Click here to download the full example code Render plane manipulator (library) An example controlling the render plane manipulator, using napari-threedee as a library. from napari_threedee.manipulators._qt import QtRenderPlaneManipulatorWidget import napari from skimage import data viewer = napari . Viewer ( ndisplay = 3 ) blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) plane_parameters = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } plane_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'additive' , opacity = 0.5 , depiction = 'plane' , plane = plane_parameters ) volume_layer = viewer . add_image ( blobs , rendering = 'mip' , name = 'volume' , blending = 'additive' , opacity = 0.25 ) widget = QtRenderPlaneManipulatorWidget ( viewer ) viewer . window . add_dock_widget ( widget ) napari . run () Total running time of the script: ( 0 minutes 0.956 seconds) Download Python source code: render_plane_manipulator_library.py Download Jupyter notebook: render_plane_manipulator_library.ipynb Gallery generated by mkdocs-gallery","title":"Render plane manipulator (library)"},{"location":"generated/gallery/library/render_plane_manipulator_library/#render-plane-manipulator-library","text":"An example controlling the render plane manipulator, using napari-threedee as a library. from napari_threedee.manipulators._qt import QtRenderPlaneManipulatorWidget import napari from skimage import data viewer = napari . Viewer ( ndisplay = 3 ) blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) plane_parameters = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } plane_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'additive' , opacity = 0.5 , depiction = 'plane' , plane = plane_parameters ) volume_layer = viewer . add_image ( blobs , rendering = 'mip' , name = 'volume' , blending = 'additive' , opacity = 0.25 ) widget = QtRenderPlaneManipulatorWidget ( viewer ) viewer . window . add_dock_widget ( widget ) napari . run () Total running time of the script: ( 0 minutes 0.956 seconds) Download Python source code: render_plane_manipulator_library.py Download Jupyter notebook: render_plane_manipulator_library.ipynb Gallery generated by mkdocs-gallery","title":"Render plane manipulator (library)"},{"location":"generated/gallery/library/sphere_annotator_library/","text":"Note Click here to download the full example code Sphere annotator (library) An example controlling the sphere annotator, using napari-threedee as a library. import napari import numpy as np from skimage import data from napari_threedee.data_models import N3dSpheres from napari_threedee.annotators.spheres import SphereAnnotator CREATE_LAYER_FROM_EXISTING_DATA = True # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) # add image layer to viewer (rendering as a plane) image_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , }, ) # optionally create an n3d compatible points layer from existing data if CREATE_LAYER_FROM_EXISTING_DATA is True : centers = np . random . uniform ( 0 , 64 , size = ( 10 , 3 )) radii = np . random . uniform ( 1 , 10 , size = ( 10 ,)) points_layer = N3dSpheres ( centers = centers , radii = radii ) . as_layer () else : points_layer = None # create the annotator annotator = SphereAnnotator ( viewer = viewer , image_layer = image_layer , points_layer = points_layer , enabled = True ) # run napari viewer . axes . visible = True viewer . axes . labels = False viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 0.755 seconds) Download Python source code: sphere_annotator_library.py Download Jupyter notebook: sphere_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Sphere annotator (library)"},{"location":"generated/gallery/library/sphere_annotator_library/#sphere-annotator-library","text":"An example controlling the sphere annotator, using napari-threedee as a library. import napari import numpy as np from skimage import data from napari_threedee.data_models import N3dSpheres from napari_threedee.annotators.spheres import SphereAnnotator CREATE_LAYER_FROM_EXISTING_DATA = True # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) # add image layer to viewer (rendering as a plane) image_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , }, ) # optionally create an n3d compatible points layer from existing data if CREATE_LAYER_FROM_EXISTING_DATA is True : centers = np . random . uniform ( 0 , 64 , size = ( 10 , 3 )) radii = np . random . uniform ( 1 , 10 , size = ( 10 ,)) points_layer = N3dSpheres ( centers = centers , radii = radii ) . as_layer () else : points_layer = None # create the annotator annotator = SphereAnnotator ( viewer = viewer , image_layer = image_layer , points_layer = points_layer , enabled = True ) # run napari viewer . axes . visible = True viewer . axes . labels = False viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 0.755 seconds) Download Python source code: sphere_annotator_library.py Download Jupyter notebook: sphere_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Sphere annotator (library)"},{"location":"generated/gallery/library/surface_annotator_library/","text":"Note Click here to download the full example code Surface annotator (library) An example controlling the surface annotator, using napari-threedee as a library. import napari from skimage import data import napari_threedee as n3d # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate 3d image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) # add image layer to viewer (rendering as plane) image_layer = viewer . add_image ( blobs , name = 'orange plane' , rendering = 'average' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , }) # create annotator annotator = n3d . annotators . SurfaceAnnotator ( viewer = viewer , image_layer = image_layer , enabled = True ) # run napari viewer . layers . selection = [ image_layer ] viewer . axes . visible = True viewer . axes . labels = False viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 2.603 seconds) Download Python source code: surface_annotator_library.py Download Jupyter notebook: surface_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Surface annotator (library)"},{"location":"generated/gallery/library/surface_annotator_library/#surface-annotator-library","text":"An example controlling the surface annotator, using napari-threedee as a library. import napari from skimage import data import napari_threedee as n3d # create napari viewer viewer = napari . Viewer ( ndisplay = 3 ) # generate 3d image data blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) # add image layer to viewer (rendering as plane) image_layer = viewer . add_image ( blobs , name = 'orange plane' , rendering = 'average' , colormap = 'bop orange' , blending = 'translucent' , opacity = 0.5 , depiction = 'plane' , plane = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , }) # create annotator annotator = n3d . annotators . SurfaceAnnotator ( viewer = viewer , image_layer = image_layer , enabled = True ) # run napari viewer . layers . selection = [ image_layer ] viewer . axes . visible = True viewer . axes . labels = False viewer . camera . angles = ( - 15 , 25 , - 30 ) viewer . camera . zoom *= 0.5 napari . run () Total running time of the script: ( 0 minutes 2.603 seconds) Download Python source code: surface_annotator_library.py Download Jupyter notebook: surface_annotator_library.ipynb Gallery generated by mkdocs-gallery","title":"Surface annotator (library)"},{"location":"generated/gallery/plugin/camera_spline_plugin/","text":"Note Click here to download the full example code Camera spline (plugin) An example controlling the camera spline, using napari-threedee as a napari plugin. ```{.python } import napari import skimage viewer = napari.Viewer(ndisplay=3) blobs = skimage.data.binary_blobs( length=64, volume_fraction=0.1, n_dim=4 ).astype(float) plane_parameters_z = { 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, } plane_parameters_y = { 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, } viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='additive', opacity=0.5, depiction='plane', plane=plane_parameters_z) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane=plane_parameters_y) viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"camera spline control\" ) viewer.camera.angles = (60, 60, 60) napari.run()``` Total running time of the script: ( 0 minutes 1.992 seconds) Download Python source code: camera_spline_plugin.py Download Jupyter notebook: camera_spline_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Camera spline (plugin)"},{"location":"generated/gallery/plugin/camera_spline_plugin/#camera-spline-plugin","text":"An example controlling the camera spline, using napari-threedee as a napari plugin. ```{.python } import napari import skimage viewer = napari.Viewer(ndisplay=3) blobs = skimage.data.binary_blobs( length=64, volume_fraction=0.1, n_dim=4 ).astype(float) plane_parameters_z = { 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, } plane_parameters_y = { 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, } viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='additive', opacity=0.5, depiction='plane', plane=plane_parameters_z) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane=plane_parameters_y) viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"camera spline control\" ) viewer.camera.angles = (60, 60, 60) napari.run()``` Total running time of the script: ( 0 minutes 1.992 seconds) Download Python source code: camera_spline_plugin.py Download Jupyter notebook: camera_spline_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Camera spline (plugin)"},{"location":"generated/gallery/plugin/layer_manipulator_plugin/","text":"Note Click here to download the full example code Layer manipulator (plugin) An example controlling the layer manipulator, using napari-threedee as a napari plugin. Out: /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( 'Window._qt_window' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( '_QtMainWindow._qt_viewer' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] import napari try : from skimage.data import binary_blobs except ImportError : raise ImportError ( \"This example requires scikit-image. pip install scikit-image\" ) image = binary_blobs ( 50 , n_dim = 3 , blob_size_fraction = 0.3 , volume_fraction = 0.1 , ) viewer = napari . view_image ( image , colormap = \"magenta\" , opacity = 0.8 , blending = \"additive\" , rendering = \"iso\" , iso_threshold = 0 , name = \"image_0\" , ) image_layer_0 = viewer . layers [ 0 ] # add an addition layer that is shifted image_layer_1 = viewer . add_image ( image . copy (), colormap = \"green\" , opacity = 0.8 , blending = \"additive\" , rendering = \"iso\" , iso_threshold = 0 , name = \"image_1\" , translate = ( 20 , 20 , 20 ), ) viewer . dims . ndisplay = 3 viewer . window . add_plugin_dock_widget ( plugin_name = \"napari-threedee\" , widget_name = \"layer manipulator\" ) napari . run () Total running time of the script: ( 0 minutes 7.743 seconds) Download Python source code: layer_manipulator_plugin.py Download Jupyter notebook: layer_manipulator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Layer manipulator (plugin)"},{"location":"generated/gallery/plugin/layer_manipulator_plugin/#layer-manipulator-plugin","text":"An example controlling the layer manipulator, using napari-threedee as a napari plugin. Out: /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( 'Window._qt_window' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( '_QtMainWindow._qt_viewer' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] import napari try : from skimage.data import binary_blobs except ImportError : raise ImportError ( \"This example requires scikit-image. pip install scikit-image\" ) image = binary_blobs ( 50 , n_dim = 3 , blob_size_fraction = 0.3 , volume_fraction = 0.1 , ) viewer = napari . view_image ( image , colormap = \"magenta\" , opacity = 0.8 , blending = \"additive\" , rendering = \"iso\" , iso_threshold = 0 , name = \"image_0\" , ) image_layer_0 = viewer . layers [ 0 ] # add an addition layer that is shifted image_layer_1 = viewer . add_image ( image . copy (), colormap = \"green\" , opacity = 0.8 , blending = \"additive\" , rendering = \"iso\" , iso_threshold = 0 , name = \"image_1\" , translate = ( 20 , 20 , 20 ), ) viewer . dims . ndisplay = 3 viewer . window . add_plugin_dock_widget ( plugin_name = \"napari-threedee\" , widget_name = \"layer manipulator\" ) napari . run () Total running time of the script: ( 0 minutes 7.743 seconds) Download Python source code: layer_manipulator_plugin.py Download Jupyter notebook: layer_manipulator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Layer manipulator (plugin)"},{"location":"generated/gallery/plugin/mesh_headlight_plugin/","text":"Note Click here to download the full example code Mesh headlight (plugin) An example controlling the mesh headlight, using napari-threedee as a napari plugin. import napari import numpy as np from vispy.io import load_data_file , read_mesh # Fetch datasets - this will download dataset if datasets are not found vertices , faces , _ , _ = read_mesh ( load_data_file ( 'orig/triceratops.obj.gz' )) # put the mesh right side up, scale it up (napari#3477) and fix faces handedness vertices *= - 100 faces = faces [:, :: - 1 ] vertex_values = np . ones (( len ( vertices ),)) # create an empty viewer viewer = napari . Viewer ( ndisplay = 3 ) # add the mesh viewer . add_surface (( vertices , faces , vertex_values ), name = 'triceratops' ) # open the plugin viewer . window . add_plugin_dock_widget ( plugin_name = \"napari-threedee\" , widget_name = \"mesh lighting controls\" ) napari . run () Total running time of the script: ( 0 minutes 0.700 seconds) Download Python source code: mesh_headlight_plugin.py Download Jupyter notebook: mesh_headlight_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Mesh headlight (plugin)"},{"location":"generated/gallery/plugin/mesh_headlight_plugin/#mesh-headlight-plugin","text":"An example controlling the mesh headlight, using napari-threedee as a napari plugin. import napari import numpy as np from vispy.io import load_data_file , read_mesh # Fetch datasets - this will download dataset if datasets are not found vertices , faces , _ , _ = read_mesh ( load_data_file ( 'orig/triceratops.obj.gz' )) # put the mesh right side up, scale it up (napari#3477) and fix faces handedness vertices *= - 100 faces = faces [:, :: - 1 ] vertex_values = np . ones (( len ( vertices ),)) # create an empty viewer viewer = napari . Viewer ( ndisplay = 3 ) # add the mesh viewer . add_surface (( vertices , faces , vertex_values ), name = 'triceratops' ) # open the plugin viewer . window . add_plugin_dock_widget ( plugin_name = \"napari-threedee\" , widget_name = \"mesh lighting controls\" ) napari . run () Total running time of the script: ( 0 minutes 0.700 seconds) Download Python source code: mesh_headlight_plugin.py Download Jupyter notebook: mesh_headlight_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Mesh headlight (plugin)"},{"location":"generated/gallery/plugin/mg_execution_times/","text":"Computation times 00:19.160 total execution time for generated_gallery_plugin files: +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | layer_manipulator_plugin (docs/examples/plugin/layer_manipulator_plugin.py) | 00:07.743 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | path_annotator_plugin (docs/examples/plugin/path_annotator_plugin.py) | 00:02.274 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | camera_spline_plugin (docs/examples/plugin/camera_spline_plugin.py) | 00:01.992 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | point_annotator_plugin (docs/examples/plugin/point_annotator_plugin.py) | 00:01.964 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | sphere_annotator_plugin (docs/examples/plugin/sphere_annotator_plugin.py) | 00:01.017 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | spline_annotator_plugin (docs/examples/plugin/spline_annotator_plugin.py) | 00:01.015 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | surface_annotator_plugin (docs/examples/plugin/surface_annotator_plugin.py) | 00:00.998 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | render_plane_manipulator_plugin (docs/examples/plugin/render_plane_manipulator_plugin.py) | 00:00.880 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | mesh_headlight_plugin (docs/examples/plugin/mesh_headlight_plugin.py) | 00:00.700 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | points_manipulator_plugin (docs/examples/plugin/points_manipulator_plugin.py) | 00:00.578 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+","title":"Computation times"},{"location":"generated/gallery/plugin/mg_execution_times/#computation-times","text":"00:19.160 total execution time for generated_gallery_plugin files: +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | layer_manipulator_plugin (docs/examples/plugin/layer_manipulator_plugin.py) | 00:07.743 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | path_annotator_plugin (docs/examples/plugin/path_annotator_plugin.py) | 00:02.274 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | camera_spline_plugin (docs/examples/plugin/camera_spline_plugin.py) | 00:01.992 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | point_annotator_plugin (docs/examples/plugin/point_annotator_plugin.py) | 00:01.964 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | sphere_annotator_plugin (docs/examples/plugin/sphere_annotator_plugin.py) | 00:01.017 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | spline_annotator_plugin (docs/examples/plugin/spline_annotator_plugin.py) | 00:01.015 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | surface_annotator_plugin (docs/examples/plugin/surface_annotator_plugin.py) | 00:00.998 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | render_plane_manipulator_plugin (docs/examples/plugin/render_plane_manipulator_plugin.py) | 00:00.880 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | mesh_headlight_plugin (docs/examples/plugin/mesh_headlight_plugin.py) | 00:00.700 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | points_manipulator_plugin (docs/examples/plugin/points_manipulator_plugin.py) | 00:00.578 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------------+-----------+--------+","title":"Computation times"},{"location":"generated/gallery/plugin/path_annotator_plugin/","text":"Note Click here to download the full example code Path point annotator (plugin) An example controlling the path annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data create napari viewer viewer = napari.Viewer(ndisplay=3) generate image data blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=4).astype(float) add two image layers to viewer viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, } ) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, } ) add plugin dock widget to viewer viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"path annotator\" ) run napari viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 2.274 seconds) Download Python source code: path_annotator_plugin.py Download Jupyter notebook: path_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Path point annotator (plugin)"},{"location":"generated/gallery/plugin/path_annotator_plugin/#path-point-annotator-plugin","text":"An example controlling the path annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data","title":"Path point annotator (plugin)"},{"location":"generated/gallery/plugin/path_annotator_plugin/#create-napari-viewer","text":"viewer = napari.Viewer(ndisplay=3)","title":"create napari viewer"},{"location":"generated/gallery/plugin/path_annotator_plugin/#generate-image-data","text":"blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=4).astype(float)","title":"generate image data"},{"location":"generated/gallery/plugin/path_annotator_plugin/#add-two-image-layers-to-viewer","text":"viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, } ) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, } )","title":"add two image layers to viewer"},{"location":"generated/gallery/plugin/path_annotator_plugin/#add-plugin-dock-widget-to-viewer","text":"viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"path annotator\" )","title":"add plugin dock widget to viewer"},{"location":"generated/gallery/plugin/path_annotator_plugin/#run-napari","text":"viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 2.274 seconds) Download Python source code: path_annotator_plugin.py Download Jupyter notebook: path_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"run napari"},{"location":"generated/gallery/plugin/point_annotator_plugin/","text":"Note Click here to download the full example code Plane point annotator (plugin) An example controlling the point annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data create napari viewer viewer = napari.Viewer(ndisplay=3) generate image data blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=4).astype(float) add two image layers to viewer viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, }) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, }) add plugin dock widget to viewer viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"point annotator\" ) run napari viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 1.964 seconds) Download Python source code: point_annotator_plugin.py Download Jupyter notebook: point_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Plane point annotator (plugin)"},{"location":"generated/gallery/plugin/point_annotator_plugin/#plane-point-annotator-plugin","text":"An example controlling the point annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data","title":"Plane point annotator (plugin)"},{"location":"generated/gallery/plugin/point_annotator_plugin/#create-napari-viewer","text":"viewer = napari.Viewer(ndisplay=3)","title":"create napari viewer"},{"location":"generated/gallery/plugin/point_annotator_plugin/#generate-image-data","text":"blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=4).astype(float)","title":"generate image data"},{"location":"generated/gallery/plugin/point_annotator_plugin/#add-two-image-layers-to-viewer","text":"viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, }) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, })","title":"add two image layers to viewer"},{"location":"generated/gallery/plugin/point_annotator_plugin/#add-plugin-dock-widget-to-viewer","text":"viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"point annotator\" )","title":"add plugin dock widget to viewer"},{"location":"generated/gallery/plugin/point_annotator_plugin/#run-napari","text":"viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 1.964 seconds) Download Python source code: point_annotator_plugin.py Download Jupyter notebook: point_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"run napari"},{"location":"generated/gallery/plugin/points_manipulator_plugin/","text":"Note Click here to download the full example code Points manipulator (plugin) Example of using the points manipulator to re-position points, using napari-threedee as a napari plugin. Enter the point selection mode and click on a point to activate the manipulator. Click and drag the arms of the manipulator to move the point. When a point is selected, hold space to rotate the view without losing the selection. import numpy as np import napari points_data = np . array ( [ [ 0 , 0 , 0 ], [ 0 , 200 , 0 ], [ 0 , 0 , 200 ] ] ) viewer = napari . Viewer ( ndisplay = 3 ) points_layer = viewer . add_points ( points_data , size = 5 ) napari . run () Total running time of the script: ( 0 minutes 0.578 seconds) Download Python source code: points_manipulator_plugin.py Download Jupyter notebook: points_manipulator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Points manipulator (plugin)"},{"location":"generated/gallery/plugin/points_manipulator_plugin/#points-manipulator-plugin","text":"Example of using the points manipulator to re-position points, using napari-threedee as a napari plugin. Enter the point selection mode and click on a point to activate the manipulator. Click and drag the arms of the manipulator to move the point. When a point is selected, hold space to rotate the view without losing the selection. import numpy as np import napari points_data = np . array ( [ [ 0 , 0 , 0 ], [ 0 , 200 , 0 ], [ 0 , 0 , 200 ] ] ) viewer = napari . Viewer ( ndisplay = 3 ) points_layer = viewer . add_points ( points_data , size = 5 ) napari . run () Total running time of the script: ( 0 minutes 0.578 seconds) Download Python source code: points_manipulator_plugin.py Download Jupyter notebook: points_manipulator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Points manipulator (plugin)"},{"location":"generated/gallery/plugin/render_plane_manipulator_plugin/","text":"Note Click here to download the full example code Render plane manipulator (plugin) An example controlling the render plane manipulator, using napari-threedee as a napari plugin. Out: /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( 'Window._qt_window' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( '_QtMainWindow._qt_viewer' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] import napari from skimage import data viewer = napari . Viewer ( ndisplay = 3 ) # add a volume blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) volume_layer = viewer . add_image ( blobs , rendering = 'mip' , name = 'volume' , blending = 'additive' , opacity = 0.25 ) # add the same volume and render as plane # plane should be in 'additive' blending mode or depth looks all wrong plane_parameters = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } plane_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'additive' , opacity = 0.5 , depiction = \"plane\" , plane = plane_parameters ) viewer . window . add_plugin_dock_widget ( plugin_name = \"napari-threedee\" , widget_name = \"render plane manipulator\" ) napari . run () Total running time of the script: ( 0 minutes 0.880 seconds) Download Python source code: render_plane_manipulator_plugin.py Download Jupyter notebook: render_plane_manipulator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Render plane manipulator (plugin)"},{"location":"generated/gallery/plugin/render_plane_manipulator_plugin/#render-plane-manipulator-plugin","text":"An example controlling the render plane manipulator, using napari-threedee as a napari plugin. Out: /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( 'Window._qt_window' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] /home/runner/work/napari-threedee/napari-threedee/src/napari_threedee/utils/napari_utils.py:38: FutureWarning: Private attribute access ( '_QtMainWindow._qt_viewer' ) in this context ( e.g. inside a plugin widget or dock widget ) is deprecated and will be unavailable in version 0 .5.0 visual = viewer.window._qt_window._qt_viewer.layer_to_visual [ layer ] import napari from skimage import data viewer = napari . Viewer ( ndisplay = 3 ) # add a volume blobs = data . binary_blobs ( length = 64 , volume_fraction = 0.1 , n_dim = 3 ) . astype ( float ) volume_layer = viewer . add_image ( blobs , rendering = 'mip' , name = 'volume' , blending = 'additive' , opacity = 0.25 ) # add the same volume and render as plane # plane should be in 'additive' blending mode or depth looks all wrong plane_parameters = { 'position' : ( 32 , 32 , 32 ), 'normal' : ( 1 , 0 , 0 ), 'thickness' : 10 , } plane_layer = viewer . add_image ( blobs , rendering = 'average' , name = 'plane' , colormap = 'bop orange' , blending = 'additive' , opacity = 0.5 , depiction = \"plane\" , plane = plane_parameters ) viewer . window . add_plugin_dock_widget ( plugin_name = \"napari-threedee\" , widget_name = \"render plane manipulator\" ) napari . run () Total running time of the script: ( 0 minutes 0.880 seconds) Download Python source code: render_plane_manipulator_plugin.py Download Jupyter notebook: render_plane_manipulator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Render plane manipulator (plugin)"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/","text":"Note Click here to download the full example code Sphere annotator (plugin) An example controlling the sphere annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data create napari viewer viewer = napari.Viewer(ndisplay=3) generate image data blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float) add two image layers to viewer viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, }) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, }) add plugin dock widget to viewer viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"sphere annotator\" ) run napari viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 1.017 seconds) Download Python source code: sphere_annotator_plugin.py Download Jupyter notebook: sphere_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Sphere annotator (plugin)"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#sphere-annotator-plugin","text":"An example controlling the sphere annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data","title":"Sphere annotator (plugin)"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#create-napari-viewer","text":"viewer = napari.Viewer(ndisplay=3)","title":"create napari viewer"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#generate-image-data","text":"blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)","title":"generate image data"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#add-two-image-layers-to-viewer","text":"viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, }) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, })","title":"add two image layers to viewer"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#add-plugin-dock-widget-to-viewer","text":"viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"sphere annotator\" )","title":"add plugin dock widget to viewer"},{"location":"generated/gallery/plugin/sphere_annotator_plugin/#run-napari","text":"viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 1.017 seconds) Download Python source code: sphere_annotator_plugin.py Download Jupyter notebook: sphere_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"run napari"},{"location":"generated/gallery/plugin/spline_annotator_plugin/","text":"Note Click here to download the full example code Spline annotator (plugin) An example controlling the spline annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data create napari viewer viewer = napari.Viewer(ndisplay=3) generate image data blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float) add two image layers to viewer viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, }) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, }) add plugin dock widget to viewer viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"sphere annotator\" ) run napari viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 1.015 seconds) Download Python source code: spline_annotator_plugin.py Download Jupyter notebook: spline_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Spline annotator (plugin)"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#spline-annotator-plugin","text":"An example controlling the spline annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data","title":"Spline annotator (plugin)"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#create-napari-viewer","text":"viewer = napari.Viewer(ndisplay=3)","title":"create napari viewer"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#generate-image-data","text":"blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)","title":"generate image data"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#add-two-image-layers-to-viewer","text":"viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, }) viewer.add_image( blobs, name='blue plane', rendering='average', colormap='bop blue', blending='additive', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (0, 1, 0), 'thickness': 10, })","title":"add two image layers to viewer"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#add-plugin-dock-widget-to-viewer","text":"viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"sphere annotator\" )","title":"add plugin dock widget to viewer"},{"location":"generated/gallery/plugin/spline_annotator_plugin/#run-napari","text":"viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 1.015 seconds) Download Python source code: spline_annotator_plugin.py Download Jupyter notebook: spline_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"run napari"},{"location":"generated/gallery/plugin/surface_annotator_plugin/","text":"Note Click here to download the full example code Surface annotator example (plugin) An example controlling the surface annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data create napari viewer viewer = napari.Viewer(ndisplay=3) generate image data blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float) add an image layers to the viewer viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, }) add plugin dock widget to viewer viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"surface annotator\" ) run napari viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 0.998 seconds) Download Python source code: surface_annotator_plugin.py Download Jupyter notebook: surface_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"Surface annotator example (plugin)"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#surface-annotator-example-plugin","text":"An example controlling the surface annotator, using napari-threedee as a napari plugin. ```{.python } import napari from skimage import data","title":"Surface annotator example (plugin)"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#create-napari-viewer","text":"viewer = napari.Viewer(ndisplay=3)","title":"create napari viewer"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#generate-image-data","text":"blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(float)","title":"generate image data"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#add-an-image-layers-to-the-viewer","text":"viewer.add_image( blobs, name='orange plane', rendering='average', colormap='bop orange', blending='translucent', opacity=0.5, depiction='plane', plane={ 'position': (32, 32, 32), 'normal': (1, 0, 0), 'thickness': 10, })","title":"add an image layers to the viewer"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#add-plugin-dock-widget-to-viewer","text":"viewer.window.add_plugin_dock_widget( plugin_name=\"napari-threedee\", widget_name=\"surface annotator\" )","title":"add plugin dock widget to viewer"},{"location":"generated/gallery/plugin/surface_annotator_plugin/#run-napari","text":"viewer.layers.selection = [viewer.layers[0]] viewer.axes.visible = True viewer.camera.angles = (-15, 25, -30) viewer.camera.zoom *= 0.5 napari.run()``` Total running time of the script: ( 0 minutes 0.998 seconds) Download Python source code: surface_annotator_plugin.py Download Jupyter notebook: surface_annotator_plugin.ipynb Gallery generated by mkdocs-gallery","title":"run napari"},{"location":"getting_started/developers/","text":"Geting started for developers Explanations of the core concepts and manipulators. Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"for developers"},{"location":"getting_started/developers/#geting-started-for-developers","text":"Explanations of the core concepts and manipulators. Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"Geting started for developers"},{"location":"getting_started/users/","text":"Getting started for users Tutorials Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"for users"},{"location":"getting_started/users/#getting-started-for-users","text":"Tutorials Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"Getting started for users"},{"location":"how_to/layer_manipulator/","text":"How to position layers with the layer manipulator Summary Sometimes objects in your data have a systematic shift relative to one another. If you need to position an entire dataset, you can use the layer manipulator. This article describes how to interactively position a layer using the layer manipulator. Instructions Open the layer_manipulator.py example from the docs. The viewer is initalized in 3D rendering mode. You can click and drag in the canvas to rotate the view. Note that the two layers are the same image, but not aligned. Select the \"image_1\" layer in the layer manipulator plugin. We will move layer \"image_1\" (the green one) to be aligned with layer \"image_0\". Activate the layer manipulator plugin. When the plugin is activated, you will see the manipulator at (0, 0, 0) on image_1. Click and drag the manipulator to align the rows. Since the layers are being rendered with additive blending, the image turns white where the layers are overlapping.","title":"interactively position layers"},{"location":"how_to/layer_manipulator/#how-to-position-layers-with-the-layer-manipulator","text":"","title":"How to position layers with the layer manipulator"},{"location":"how_to/layer_manipulator/#summary","text":"Sometimes objects in your data have a systematic shift relative to one another. If you need to position an entire dataset, you can use the layer manipulator. This article describes how to interactively position a layer using the layer manipulator.","title":"Summary"},{"location":"how_to/layer_manipulator/#instructions","text":"Open the layer_manipulator.py example from the docs. The viewer is initalized in 3D rendering mode. You can click and drag in the canvas to rotate the view. Note that the two layers are the same image, but not aligned. Select the \"image_1\" layer in the layer manipulator plugin. We will move layer \"image_1\" (the green one) to be aligned with layer \"image_0\". Activate the layer manipulator plugin. When the plugin is activated, you will see the manipulator at (0, 0, 0) on image_1. Click and drag the manipulator to align the rows. Since the layers are being rendered with additive blending, the image turns white where the layers are overlapping.","title":"Instructions"},{"location":"how_to/point_annotator/","text":"Annotate points on an arbitrary plane Summary Annotating points in 3D can be useful for picking particles in CryoET and annotating locations of landmarks. However, doing so on a 2D computer screen is challenging. Here we demonstrate how to use the point annotator, which annotates points on arbitrary slicing planes. Instructions Open the plane_point_annotator.py example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing two 3D volumes, each with one plane being actively rendered. Activate the plugin. Select the orange layer for the \"image layer\" and Points for the \"points layer\". Finally click the \"activate\" button. This will add points to the Points layer based on the intersection of the click ray with the currently rendered orange layer. You can translate the rendered orange play along its normal vector by holding the shift key while clicking with the left mouse button and dragging the plane. You can add points on the rendered plane by holding the alt key while clicking with the left mouse button. You can move the plane to annotate a new plane by clicking and dragging with the shift key as in step 3.","title":"annotate points in 3D"},{"location":"how_to/point_annotator/#annotate-points-on-an-arbitrary-plane","text":"","title":"Annotate points on an arbitrary plane"},{"location":"how_to/point_annotator/#summary","text":"Annotating points in 3D can be useful for picking particles in CryoET and annotating locations of landmarks. However, doing so on a 2D computer screen is challenging. Here we demonstrate how to use the point annotator, which annotates points on arbitrary slicing planes.","title":"Summary"},{"location":"how_to/point_annotator/#instructions","text":"Open the plane_point_annotator.py example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing two 3D volumes, each with one plane being actively rendered. Activate the plugin. Select the orange layer for the \"image layer\" and Points for the \"points layer\". Finally click the \"activate\" button. This will add points to the Points layer based on the intersection of the click ray with the currently rendered orange layer. You can translate the rendered orange play along its normal vector by holding the shift key while clicking with the left mouse button and dragging the plane. You can add points on the rendered plane by holding the alt key while clicking with the left mouse button. You can move the plane to annotate a new plane by clicking and dragging with the shift key as in step 3.","title":"Instructions"},{"location":"how_to/point_manipulator/","text":"How to position points with the point manipulator Summary Precisely positioning a point in 3D is a useful way to annotate specific positions or choose the location of an object in a scene. This article explains how to use the napari-threedee point manipulator plugin to position points in 3D. Instructions Open the points_manipulator.py example. The example opens in 3D rendering mode. Click and drag to rotate the view. Open the point manipulator plugin from the Plugins menu: Plugins -> napari-threedee -> point manipulator. Click the \"activate\" to start the plugin. Set the Points later to \"Selection\" mode by clicking the \"Selection\" button in the layer controls Select a point by clicking on it. The point manipulator will appear on the selected point. You can now move the point around by clicking and dragging the manipulator. If you want to rotate the view while a point manipulator is active, press and hold the space bar while clicking and dragging in the canvas to rotate the view. The manipulator will be rendered invisible while you rotate so you can see the whole scene.","title":"interactively position points"},{"location":"how_to/point_manipulator/#how-to-position-points-with-the-point-manipulator","text":"","title":"How to position points with the point manipulator"},{"location":"how_to/point_manipulator/#summary","text":"Precisely positioning a point in 3D is a useful way to annotate specific positions or choose the location of an object in a scene. This article explains how to use the napari-threedee point manipulator plugin to position points in 3D.","title":"Summary"},{"location":"how_to/point_manipulator/#instructions","text":"Open the points_manipulator.py example. The example opens in 3D rendering mode. Click and drag to rotate the view. Open the point manipulator plugin from the Plugins menu: Plugins -> napari-threedee -> point manipulator. Click the \"activate\" to start the plugin. Set the Points later to \"Selection\" mode by clicking the \"Selection\" button in the layer controls Select a point by clicking on it. The point manipulator will appear on the selected point. You can now move the point around by clicking and dragging the manipulator. If you want to rotate the view while a point manipulator is active, press and hold the space bar while clicking and dragging in the canvas to rotate the view. The manipulator will be rendered invisible while you rotate so you can see the whole scene.","title":"Instructions"},{"location":"how_to/render_plane_manipulator/","text":"How to use the render plane manipulator Summary The render plane manipulator allows you to interactively position the plane being visualized in the napari Image layer plane depiction mode. The plane depiction mode is a 3D rendering mode where only the specified plane is rendered. This is a power rendering mode for visualizing structures within a 3D volume, but defining the precise plane programatically can be challenging. Thus, the render plane manipulator is useful for interactively positioning the rendering plane. Instructions Launch napari . Open your terminal and activate your napari-threedee environment. Enter napari in the command prompt to launch napari. napari Load the \"HIV virus-like particles tomogram\" image from the File menu: File -> Open Sample -> HIV virus-like particle tomogram. Note that this will download the sample image so it make take some time. If you have previously opened the sample image, it should be cached and will not download again. Click the \"Toggle ndisplay\" button in the lower left corner of the viewer to enter 3D rendering mode. Upon clicking the button, you will see the volume in 3D. You you can click and drag to rotate the view. Note that the HIV particles are visible, but low contrast. In the layer controls, change the depiction mode from volume to plane . After changing the depiction mode, you will see a single plane being rendered from your 3d volume. Open the render plane manipulator plugin from the menu: Plugins -> napari-threedee -> render plane manipulator. You will see the render plane manipulator appear on the rendering plane. You can click and drag the translator on the manipulator to translate the plane along its normal. You can click and drag the rotator to rotate the plane around the manipulator. If you would like to change the center of rotation, you can press the shift key while clicking on the plane with the left mouse button to move the manipulator.","title":"interactively position a render plane"},{"location":"how_to/render_plane_manipulator/#how-to-use-the-render-plane-manipulator","text":"","title":"How to use the render plane manipulator"},{"location":"how_to/render_plane_manipulator/#summary","text":"The render plane manipulator allows you to interactively position the plane being visualized in the napari Image layer plane depiction mode. The plane depiction mode is a 3D rendering mode where only the specified plane is rendered. This is a power rendering mode for visualizing structures within a 3D volume, but defining the precise plane programatically can be challenging. Thus, the render plane manipulator is useful for interactively positioning the rendering plane.","title":"Summary"},{"location":"how_to/render_plane_manipulator/#instructions","text":"Launch napari . Open your terminal and activate your napari-threedee environment. Enter napari in the command prompt to launch napari. napari Load the \"HIV virus-like particles tomogram\" image from the File menu: File -> Open Sample -> HIV virus-like particle tomogram. Note that this will download the sample image so it make take some time. If you have previously opened the sample image, it should be cached and will not download again. Click the \"Toggle ndisplay\" button in the lower left corner of the viewer to enter 3D rendering mode. Upon clicking the button, you will see the volume in 3D. You you can click and drag to rotate the view. Note that the HIV particles are visible, but low contrast. In the layer controls, change the depiction mode from volume to plane . After changing the depiction mode, you will see a single plane being rendered from your 3d volume. Open the render plane manipulator plugin from the menu: Plugins -> napari-threedee -> render plane manipulator. You will see the render plane manipulator appear on the rendering plane. You can click and drag the translator on the manipulator to translate the plane along its normal. You can click and drag the rotator to rotate the plane around the manipulator. If you would like to change the center of rotation, you can press the shift key while clicking on the plane with the left mouse button to move the manipulator.","title":"Instructions"},{"location":"how_to/sphere_annotator/","text":"Annotate spheres on arbitrary planes Summary Annotating spheres in 3D is useful for defining regions of interest around a point. Here we describe how to annotate a sphere on an arbitrary plane in an image. Instructions Open the sphere_annotator.py example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing a 3D volume with one plane being actively rendered. Activate the plugin. Select the plane layer for the \"image layer\" and click the \"activate\" button. This will add points to the Points layer based on the intersection of the click ray with the currently rendered orange layer. You can translate the rendered orange play along its normal vector by holding the shift key while clicking with the left mouse button and dragging the plane. You can add a sphere on the rendered play by holding alt and clicking on the plane with the left mouse button. If you alt+click again, it will reposition the sphere. You can adjust the radius of the sphere by presing the r key and the sphere will snap to the position where your mouse pointer intersects the rendered plane. You add a new point by pressing the n key and repeating steps 5 and 6.","title":"annotate spheres in 3D"},{"location":"how_to/sphere_annotator/#annotate-spheres-on-arbitrary-planes","text":"","title":"Annotate spheres on arbitrary planes"},{"location":"how_to/sphere_annotator/#summary","text":"Annotating spheres in 3D is useful for defining regions of interest around a point. Here we describe how to annotate a sphere on an arbitrary plane in an image.","title":"Summary"},{"location":"how_to/sphere_annotator/#instructions","text":"Open the sphere_annotator.py example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing a 3D volume with one plane being actively rendered. Activate the plugin. Select the plane layer for the \"image layer\" and click the \"activate\" button. This will add points to the Points layer based on the intersection of the click ray with the currently rendered orange layer. You can translate the rendered orange play along its normal vector by holding the shift key while clicking with the left mouse button and dragging the plane. You can add a sphere on the rendered play by holding alt and clicking on the plane with the left mouse button. If you alt+click again, it will reposition the sphere. You can adjust the radius of the sphere by presing the r key and the sphere will snap to the position where your mouse pointer intersects the rendered plane. You add a new point by pressing the n key and repeating steps 5 and 6.","title":"Instructions"},{"location":"how_to/spline_annotator/","text":"Annotate 3D splines Summary Spines are useful for describing paths through your data. This tutorial describes how use the spline annotator to interactively add splines in a 3D image. Instructions Open the spline_annotator.py example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing two 3D volumes, each with one plane being actively rendered. Activate the plugin. Select the orange layer for the \"image layer\" and click the \"activate\" button. You can translate the rendered orange play along its normal vector by holding the shift key while clicking with the left mouse button and dragging the plane. You can add a spline by ctrl+left mouse button clicking on the rendered plane to add points to the plane. The annotator will fit a third order spline when 4 or more points have been added. If you don't want the spline to be automatically fit, you can uncheck the \"automatically fit spline\" checkbox. If you are not automatically fitting the spline, you need to click the \"fit spline\" button to manually initiate the spline fitting. You can add additional splines by advancing the \"current spline index\". Each spline is given a unique index. Points are added to the spline whose index is currently selected. Additionally, to make a spline that doesn't lie in a single plane, you can add points to mutiple planes by moving the rendered plane.","title":"annotate splines in 3D"},{"location":"how_to/spline_annotator/#annotate-3d-splines","text":"","title":"Annotate 3D splines"},{"location":"how_to/spline_annotator/#summary","text":"Spines are useful for describing paths through your data. This tutorial describes how use the spline annotator to interactively add splines in a 3D image.","title":"Summary"},{"location":"how_to/spline_annotator/#instructions","text":"Open the spline_annotator.py example from the examples folder. The viewer is initialized in 3D rendering mode in plane rendering mode. We are viewing two 3D volumes, each with one plane being actively rendered. Activate the plugin. Select the orange layer for the \"image layer\" and click the \"activate\" button. You can translate the rendered orange play along its normal vector by holding the shift key while clicking with the left mouse button and dragging the plane. You can add a spline by ctrl+left mouse button clicking on the rendered plane to add points to the plane. The annotator will fit a third order spline when 4 or more points have been added. If you don't want the spline to be automatically fit, you can uncheck the \"automatically fit spline\" checkbox. If you are not automatically fitting the spline, you need to click the \"fit spline\" button to manually initiate the spline fitting. You can add additional splines by advancing the \"current spline index\". Each spline is given a unique index. Points are added to the spline whose index is currently selected. Additionally, to make a spline that doesn't lie in a single plane, you can add points to mutiple planes by moving the rendered plane.","title":"Instructions"},{"location":"tutorials/tutorials/","text":"Tutorials","title":"Tutorials"},{"location":"tutorials/tutorials/#tutorials","text":"","title":"Tutorials"}]}