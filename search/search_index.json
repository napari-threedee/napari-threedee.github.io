{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview napari-threedee is a collection of tools for exploring, manipulating, and annotating your data in 3D. Installation napari-threedee is a napari plugin and thus requires napari to work. You can see the napari documentation for napari installation instructions . After you have installed napari , you can install napari-threedee using the package manager of your choice using the commands below. pip conda pip install napari-threedee conda install -c conda-forge napari-threedee Getting started Users Do you have rich 3D (or more!) data that you want to explore and annotate? napari-threedee comes with a collection of plugins for just that. Please see our Getting started for users guide to get going. Developers Are you developing an image processing workflow that requires exploration or annotation of multidimensional data? napari-threedee has a collection of composable compoents for adding 3D interactivity to your workflow! To get started, see our Getting started for developers guide .","title":"Overview"},{"location":"#overview","text":"napari-threedee is a collection of tools for exploring, manipulating, and annotating your data in 3D.","title":"Overview"},{"location":"#installation","text":"napari-threedee is a napari plugin and thus requires napari to work. You can see the napari documentation for napari installation instructions . After you have installed napari , you can install napari-threedee using the package manager of your choice using the commands below. pip conda pip install napari-threedee conda install -c conda-forge napari-threedee","title":"Installation"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#users","text":"Do you have rich 3D (or more!) data that you want to explore and annotate? napari-threedee comes with a collection of plugins for just that. Please see our Getting started for users guide to get going.","title":"Users"},{"location":"#developers","text":"Are you developing an image processing workflow that requires exploration or annotation of multidimensional data? napari-threedee has a collection of composable compoents for adding 3D interactivity to your workflow! To get started, see our Getting started for developers guide .","title":"Developers"},{"location":"API/geometry_utilities/","text":"Geometry utilities napari_threedee.utils.geometry signed_angle_between_vectors ( vector_0 , vector_1 , rotation_axis : np . ndarray ) -> float Returns the angle in radians between vectors 'v1' and 'v2'. PARAMETER DESCRIPTION vector_0 The vector to start the rotation at. TYPE: np . ndarray vector_1 The vector the rotation ends at. TYPE: np . ndarray rotation_axis The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. TYPE: np . ndarray RETURNS DESCRIPTION angle The signed angle of rotation in radians. TYPE: float Source code in napari_threedee/utils/geometry.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def signed_angle_between_vectors ( vector_0 , vector_1 , rotation_axis : np . ndarray ) -> float : \"\"\" Returns the angle in radians between vectors 'v1' and 'v2'. Parameters ---------- vector_0 : np.ndarray The vector to start the rotation at. vector_1 : np.ndarray The vector the rotation ends at. rotation_axis : np.ndarray The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. Returns ------- angle : float The signed angle of rotation in radians. \"\"\" unit_vector_0 = vector_0 / np . linalg . norm ( vector_0 ) unit_vector_1 = vector_1 / np . linalg . norm ( vector_1 ) unsigned_angle = np . arccos ( np . clip ( np . dot ( unit_vector_0 , unit_vector_1 ), - 1.0 , 1.0 )) v3 = np . cross ( unit_vector_0 , unit_vector_1 ) angle_sign = - 1 if np . dot ( v3 , rotation_axis ) < 0 else 1 return angle_sign * unsigned_angle rotation_matrix_around_vector_3d ( angle : float , vector : np . ndarray ) -> np . ndarray Create the rotation matrix for a specified angle of rotation around a vector. PARAMETER DESCRIPTION angle The signed angle of rotation in radians. TYPE: float vector : np.ndarray The vector around which to perform the rotation. RETURNS DESCRIPTION rotation_matrix (3, 3) rotation matrix for the specified rotation. TYPE: np . ndarray Source code in napari_threedee/utils/geometry.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def rotation_matrix_around_vector_3d ( angle : float , vector : np . ndarray ) -> np . ndarray : \"\"\"Create the rotation matrix for a specified angle of rotation around a vector. Parameters ---------- angle : float The signed angle of rotation in radians. vector : np.ndarray The vector around which to perform the rotation. Returns ------- rotation_matrix : np.ndarray (3, 3) rotation matrix for the specified rotation. \"\"\" vector_u = vector / np . linalg . norm ( vector ) u_0 = vector_u [ 0 ] u_1 = vector_u [ 1 ] u_2 = vector_u [ 2 ] cos_term = 1 - np . cos ( angle ) sine_term = np . sin ( angle ) rotation_matrix = np . zeros (( 3 , 3 )) rotation_matrix [ 0 , 0 ] = np . cos ( angle ) + ( u_0 ** 2 ) * cos_term rotation_matrix [ 0 , 1 ] = ( u_0 * u_1 * cos_term ) - u_2 * sine_term rotation_matrix [ 0 , 2 ] = ( u_0 * u_2 * cos_term ) + u_1 * sine_term rotation_matrix [ 1 , 0 ] = ( u_1 * u_0 * cos_term ) + u_2 * sine_term rotation_matrix [ 1 , 1 ] = np . cos ( angle ) + ( u_1 ** 2 ) * cos_term rotation_matrix [ 1 , 2 ] = ( u_1 * u_2 * cos_term ) - u_0 * sine_term rotation_matrix [ 2 , 0 ] = ( u_0 * u_2 * cos_term ) - u_1 * sine_term rotation_matrix [ 2 , 1 ] = u_1 * u_2 * cos_term + u_0 * sine_term rotation_matrix [ 2 , 2 ] = np . cos ( angle ) + ( u_2 ** 2 ) * cos_term return rotation_matrix","title":"Geometry utilities"},{"location":"API/geometry_utilities/#geometry-utilities","text":"","title":"Geometry utilities"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry","text":"","title":"geometry"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.signed_angle_between_vectors","text":"Returns the angle in radians between vectors 'v1' and 'v2'. PARAMETER DESCRIPTION vector_0 The vector to start the rotation at. TYPE: np . ndarray vector_1 The vector the rotation ends at. TYPE: np . ndarray rotation_axis The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. TYPE: np . ndarray RETURNS DESCRIPTION angle The signed angle of rotation in radians. TYPE: float Source code in napari_threedee/utils/geometry.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def signed_angle_between_vectors ( vector_0 , vector_1 , rotation_axis : np . ndarray ) -> float : \"\"\" Returns the angle in radians between vectors 'v1' and 'v2'. Parameters ---------- vector_0 : np.ndarray The vector to start the rotation at. vector_1 : np.ndarray The vector the rotation ends at. rotation_axis : np.ndarray The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1. Returns ------- angle : float The signed angle of rotation in radians. \"\"\" unit_vector_0 = vector_0 / np . linalg . norm ( vector_0 ) unit_vector_1 = vector_1 / np . linalg . norm ( vector_1 ) unsigned_angle = np . arccos ( np . clip ( np . dot ( unit_vector_0 , unit_vector_1 ), - 1.0 , 1.0 )) v3 = np . cross ( unit_vector_0 , unit_vector_1 ) angle_sign = - 1 if np . dot ( v3 , rotation_axis ) < 0 else 1 return angle_sign * unsigned_angle","title":"signed_angle_between_vectors()"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.rotation_matrix_around_vector_3d","text":"Create the rotation matrix for a specified angle of rotation around a vector. PARAMETER DESCRIPTION angle The signed angle of rotation in radians. TYPE: float vector : np.ndarray The vector around which to perform the rotation. RETURNS DESCRIPTION rotation_matrix (3, 3) rotation matrix for the specified rotation. TYPE: np . ndarray Source code in napari_threedee/utils/geometry.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def rotation_matrix_around_vector_3d ( angle : float , vector : np . ndarray ) -> np . ndarray : \"\"\"Create the rotation matrix for a specified angle of rotation around a vector. Parameters ---------- angle : float The signed angle of rotation in radians. vector : np.ndarray The vector around which to perform the rotation. Returns ------- rotation_matrix : np.ndarray (3, 3) rotation matrix for the specified rotation. \"\"\" vector_u = vector / np . linalg . norm ( vector ) u_0 = vector_u [ 0 ] u_1 = vector_u [ 1 ] u_2 = vector_u [ 2 ] cos_term = 1 - np . cos ( angle ) sine_term = np . sin ( angle ) rotation_matrix = np . zeros (( 3 , 3 )) rotation_matrix [ 0 , 0 ] = np . cos ( angle ) + ( u_0 ** 2 ) * cos_term rotation_matrix [ 0 , 1 ] = ( u_0 * u_1 * cos_term ) - u_2 * sine_term rotation_matrix [ 0 , 2 ] = ( u_0 * u_2 * cos_term ) + u_1 * sine_term rotation_matrix [ 1 , 0 ] = ( u_1 * u_0 * cos_term ) + u_2 * sine_term rotation_matrix [ 1 , 1 ] = np . cos ( angle ) + ( u_1 ** 2 ) * cos_term rotation_matrix [ 1 , 2 ] = ( u_1 * u_2 * cos_term ) - u_0 * sine_term rotation_matrix [ 2 , 0 ] = ( u_0 * u_2 * cos_term ) - u_1 * sine_term rotation_matrix [ 2 , 1 ] = u_1 * u_2 * cos_term + u_0 * sine_term rotation_matrix [ 2 , 2 ] = np . cos ( angle ) + ( u_2 ** 2 ) * cos_term return rotation_matrix","title":"rotation_matrix_around_vector_3d()"},{"location":"API/napari_utilities/","text":"napari utilities napari_threedee.utils.napari_utils get_napari_visual ( viewer , layer ) Get the visual class for a given layer PARAMETER DESCRIPTION viewer The napari viewer object layer The napari layer object for which to find the visual. RETURNS DESCRIPTION visual The napari visual class for the layer. Source code in napari_threedee/utils/napari_utils.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get_napari_visual ( viewer , layer ): \"\"\"Get the visual class for a given layer Parameters ---------- viewer The napari viewer object layer The napari layer object for which to find the visual. Returns ------- visual The napari visual class for the layer. \"\"\" visual = viewer . window . _qt_window . _qt_viewer . layer_to_visual [ layer ] return visual get_mouse_position_in_displayed_dimensions ( event ) -> np . ndarray Get the position under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event The mouse event. RETURNS DESCRIPTION click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in napari_threedee/utils/napari_utils.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_mouse_position_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the position under the mouse in scene (displayed world) coordinates. Parameters ---------- event The mouse event. Returns ------- click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position return np . asarray ( click_position_world )[ list ( event . dims_displayed )] get_view_direction_in_displayed_dimensions ( event ) -> np . ndarray Get the view direction under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event napari mouse event. Source code in napari_threedee/utils/napari_utils.py 100 101 102 103 104 105 106 107 108 109 def get_view_direction_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the view direction under the mouse in scene (displayed world) coordinates. Parameters ---------- event: Event napari mouse event. \"\"\" view_direction_world = event . view_direction return np . asarray ( view_direction_world )[ list ( event . dims_displayed )] get_mouse_position_in_displayed_layer_data_coordinates ( layer , event ) -> Tuple [ np . ndarray , np . ndarray ] Get the mouse click position and direction in layer data displayed coordinates. PARAMETER DESCRIPTION layer The layer to convert the coordinates to. TYPE: napari . layers . Layer event The mouse event. RETURNS DESCRIPTION click_position_data_3d The click position in displayed data coordinates. TYPE: np . ndarray click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in napari_threedee/utils/napari_utils.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def get_mouse_position_in_displayed_layer_data_coordinates ( layer , event ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Get the mouse click position and direction in layer data displayed coordinates. Parameters ---------- layer : napari.layers.Layer The layer to convert the coordinates to. event The mouse event. Returns ------- click_position_data_3d : np.ndarray The click position in displayed data coordinates. click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position click_position_data_3d = np . asarray ( layer . _world_to_displayed_data ( click_position_world , event . dims_displayed ) ) click_dir_data_3d = np . asarray ( layer . _world_to_displayed_data_ray ( event . view_direction , event . dims_displayed ) ) return click_position_data_3d , click_dir_data_3d","title":"napari utilities"},{"location":"API/napari_utilities/#napari-utilities","text":"","title":"napari utilities"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils","text":"","title":"napari_utils"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_napari_visual","text":"Get the visual class for a given layer PARAMETER DESCRIPTION viewer The napari viewer object layer The napari layer object for which to find the visual. RETURNS DESCRIPTION visual The napari visual class for the layer. Source code in napari_threedee/utils/napari_utils.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get_napari_visual ( viewer , layer ): \"\"\"Get the visual class for a given layer Parameters ---------- viewer The napari viewer object layer The napari layer object for which to find the visual. Returns ------- visual The napari visual class for the layer. \"\"\" visual = viewer . window . _qt_window . _qt_viewer . layer_to_visual [ layer ] return visual","title":"get_napari_visual()"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_dimensions","text":"Get the position under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event The mouse event. RETURNS DESCRIPTION click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in napari_threedee/utils/napari_utils.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_mouse_position_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the position under the mouse in scene (displayed world) coordinates. Parameters ---------- event The mouse event. Returns ------- click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position return np . asarray ( click_position_world )[ list ( event . dims_displayed )]","title":"get_mouse_position_in_displayed_dimensions()"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_view_direction_in_displayed_dimensions","text":"Get the view direction under the mouse in scene (displayed world) coordinates. PARAMETER DESCRIPTION event napari mouse event. Source code in napari_threedee/utils/napari_utils.py 100 101 102 103 104 105 106 107 108 109 def get_view_direction_in_displayed_dimensions ( event ) -> np . ndarray : \"\"\"Get the view direction under the mouse in scene (displayed world) coordinates. Parameters ---------- event: Event napari mouse event. \"\"\" view_direction_world = event . view_direction return np . asarray ( view_direction_world )[ list ( event . dims_displayed )]","title":"get_view_direction_in_displayed_dimensions()"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_layer_data_coordinates","text":"Get the mouse click position and direction in layer data displayed coordinates. PARAMETER DESCRIPTION layer The layer to convert the coordinates to. TYPE: napari . layers . Layer event The mouse event. RETURNS DESCRIPTION click_position_data_3d The click position in displayed data coordinates. TYPE: np . ndarray click_dir_data_3d The click direction in displayed data coordiantes TYPE: np . ndarray Source code in napari_threedee/utils/napari_utils.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def get_mouse_position_in_displayed_layer_data_coordinates ( layer , event ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Get the mouse click position and direction in layer data displayed coordinates. Parameters ---------- layer : napari.layers.Layer The layer to convert the coordinates to. event The mouse event. Returns ------- click_position_data_3d : np.ndarray The click position in displayed data coordinates. click_dir_data_3d : np.ndarray The click direction in displayed data coordiantes \"\"\" click_position_world = event . position click_position_data_3d = np . asarray ( layer . _world_to_displayed_data ( click_position_world , event . dims_displayed ) ) click_dir_data_3d = np . asarray ( layer . _world_to_displayed_data_ray ( event . view_direction , event . dims_displayed ) ) return click_position_data_3d , click_dir_data_3d","title":"get_mouse_position_in_displayed_layer_data_coordinates()"},{"location":"API/selection_utilities/","text":"Selection utilities napari_threedee.utils.selection_utils distance_between_point_and_line_segment_2d ( p , p1 , p2 ) Calculate the distance between a point p and a line segment p1, p2 Source code in napari_threedee/utils/selection_utils.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def distance_between_point_and_line_segment_2d ( p , p1 , p2 ): \"\"\"Calculate the distance between a point p and a line segment p1, p2 \"\"\" x0 = p [ 0 ] y0 = p [ 1 ] x1 = p1 [ 0 ] y1 = p1 [ 1 ] x2 = p2 [ 0 ] y2 = p2 [ 1 ] numerator = np . linalg . norm (( x2 - x1 ) * ( y1 - y0 ) - ( x1 - x0 ) * ( y2 - y1 )) denominator = np . sqrt (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) return numerator / denominator select_triangle_from_click ( click_point : np . ndarray , view_direction : np . ndarray , triangles : np . ndarray ) Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. PARAMETER DESCRIPTION click_point (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. TYPE: np . ndarray view_direction (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. TYPE: np . ndarray triangles (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. TYPE: np . ndarray RETURNS DESCRIPTION in_triangles (n,) boolean array that is True of the ray intersects the triangle TYPE: np . ndarray Source code in napari_threedee/utils/selection_utils.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def select_triangle_from_click ( click_point : np . ndarray , view_direction : np . ndarray , triangles : np . ndarray ): \"\"\"Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. Parameters ---------- click_point : np.ndarray (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. view_direction : np.ndarray (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. triangles : np.ndarray (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. Returns ------- in_triangles : np.ndarray (n,) boolean array that is True of the ray intersects the triangle \"\"\" vertices = triangles . reshape (( - 1 , triangles . shape [ 2 ])) # project the vertices of the bound region on to the view plane vertices_plane , signed_distance_to_plane = project_points_onto_plane ( points = vertices , plane_point = click_point , plane_normal = view_direction ) # rotate the plane to make the triangles 2D rotation_matrix = rotation_matrix_from_vectors_3d ( view_direction , [ 0 , 0 , 1 ]) rotated_vertices = vertices_plane @ rotation_matrix . T rotated_vertices_2d = rotated_vertices [:, : 2 ] rotated_triangles_2d = rotated_vertices_2d . reshape ( - 1 , 3 , 2 ) line_pos_2D = rotation_matrix . dot ( click_point )[: 2 ] candidate_matches = inside_triangles ( rotated_triangles_2d - line_pos_2D ) candidate_match_indices = np . argwhere ( candidate_matches ) n_matches = len ( candidate_match_indices ) if n_matches == 0 : triangle_index = None elif n_matches == 1 : triangle_index = candidate_match_indices [ 0 ] else : potential_match_distances = signed_distance_to_plane [ candidate_match_indices ] triangle_index = candidate_match_indices [ np . argmin ( potential_match_distances )] return triangle_index select_sphere_from_click ( click_point : np . ndarray , view_direction : np . ndarray , sphere_centroids : np . ndarray , sphere_diameter : float ) -> Optional [ int ] Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. PARAMETER DESCRIPTION click_point The point where the click ray originates. TYPE: np . ndarray view_direction The unit vector pointing in the direction the viewer is looking. TYPE: np . ndarray sphere_centroids The (n, 3) array of center points for the n points. TYPE: np . ndarray sphere_diameter The diameter of all spheres. Must the same diameter for all spheres. TYPE: float RETURNS DESCRIPTION selection The index for the sphere that was intersected. Returns None if no spheres are intersected. TYPE: Optional [ int ] Source code in napari_threedee/utils/selection_utils.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def select_sphere_from_click ( click_point : np . ndarray , view_direction : np . ndarray , sphere_centroids : np . ndarray , sphere_diameter : float ) -> Optional [ int ]: \"\"\"Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. Parameters ---------- click_point : np.ndarray The point where the click ray originates. view_direction : np.ndarray The unit vector pointing in the direction the viewer is looking. sphere_centroids : np.ndarray The (n, 3) array of center points for the n points. sphere_diameter : float The diameter of all spheres. Must the same diameter for all spheres. Returns ------- selection : Optional[int] The index for the sphere that was intersected. Returns None if no spheres are intersected. \"\"\" # project the in view points onto the camera plane projected_points , projection_distances = project_points_onto_plane ( points = sphere_centroids , plane_point = click_point , plane_normal = view_direction , ) # rotate points and plane to be axis aligned with normal [0, 0, 1] rotated_points , rotation_matrix = rotate_points ( points = projected_points , current_plane_normal = view_direction , new_plane_normal = [ 0 , 0 , 1 ], ) rotated_click_point = np . dot ( rotation_matrix , click_point ) # find the points the click intersects n_spheres = len ( sphere_centroids ) handle_sizes = np . tile ( sphere_diameter , ( n_spheres , 1 )) distances = abs ( rotated_points [:, : 2 ] - rotated_click_point [: 2 ]) # the -1 accounts for the edge width in_slice_matches = np . all ( distances <= ( handle_sizes - 1 / 2 ) - 1.5 , axis = 1 , ) indices = np . where ( in_slice_matches )[ 0 ] if len ( indices ) > 0 : # find the point that is most in the foreground candidate_point_distances = projection_distances [ indices ] min_distance_index = np . argmin ( candidate_point_distances ) selection = indices [ min_distance_index ] else : selection = None return selection","title":"Selection utilities"},{"location":"API/selection_utilities/#selection-utilities","text":"","title":"Selection utilities"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils","text":"","title":"selection_utils"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.distance_between_point_and_line_segment_2d","text":"Calculate the distance between a point p and a line segment p1, p2 Source code in napari_threedee/utils/selection_utils.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def distance_between_point_and_line_segment_2d ( p , p1 , p2 ): \"\"\"Calculate the distance between a point p and a line segment p1, p2 \"\"\" x0 = p [ 0 ] y0 = p [ 1 ] x1 = p1 [ 0 ] y1 = p1 [ 1 ] x2 = p2 [ 0 ] y2 = p2 [ 1 ] numerator = np . linalg . norm (( x2 - x1 ) * ( y1 - y0 ) - ( x1 - x0 ) * ( y2 - y1 )) denominator = np . sqrt (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) return numerator / denominator","title":"distance_between_point_and_line_segment_2d()"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_triangle_from_click","text":"Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. PARAMETER DESCRIPTION click_point (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. TYPE: np . ndarray view_direction (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. TYPE: np . ndarray triangles (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. TYPE: np . ndarray RETURNS DESCRIPTION in_triangles (n,) boolean array that is True of the ray intersects the triangle TYPE: np . ndarray Source code in napari_threedee/utils/selection_utils.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def select_triangle_from_click ( click_point : np . ndarray , view_direction : np . ndarray , triangles : np . ndarray ): \"\"\"Determine if a line goes through any of a set of triangles. For example, this could be used to determine if a click was in a triangle of a mesh. Parameters ---------- click_point : np.ndarray (3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices. view_direction : np.ndarray (3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices. triangles : np.ndarray (n, 3, 3) array containing the coordinates for the 3 corners of n triangles. Returns ------- in_triangles : np.ndarray (n,) boolean array that is True of the ray intersects the triangle \"\"\" vertices = triangles . reshape (( - 1 , triangles . shape [ 2 ])) # project the vertices of the bound region on to the view plane vertices_plane , signed_distance_to_plane = project_points_onto_plane ( points = vertices , plane_point = click_point , plane_normal = view_direction ) # rotate the plane to make the triangles 2D rotation_matrix = rotation_matrix_from_vectors_3d ( view_direction , [ 0 , 0 , 1 ]) rotated_vertices = vertices_plane @ rotation_matrix . T rotated_vertices_2d = rotated_vertices [:, : 2 ] rotated_triangles_2d = rotated_vertices_2d . reshape ( - 1 , 3 , 2 ) line_pos_2D = rotation_matrix . dot ( click_point )[: 2 ] candidate_matches = inside_triangles ( rotated_triangles_2d - line_pos_2D ) candidate_match_indices = np . argwhere ( candidate_matches ) n_matches = len ( candidate_match_indices ) if n_matches == 0 : triangle_index = None elif n_matches == 1 : triangle_index = candidate_match_indices [ 0 ] else : potential_match_distances = signed_distance_to_plane [ candidate_match_indices ] triangle_index = candidate_match_indices [ np . argmin ( potential_match_distances )] return triangle_index","title":"select_triangle_from_click()"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_sphere_from_click","text":"Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. PARAMETER DESCRIPTION click_point The point where the click ray originates. TYPE: np . ndarray view_direction The unit vector pointing in the direction the viewer is looking. TYPE: np . ndarray sphere_centroids The (n, 3) array of center points for the n points. TYPE: np . ndarray sphere_diameter The diameter of all spheres. Must the same diameter for all spheres. TYPE: float RETURNS DESCRIPTION selection The index for the sphere that was intersected. Returns None if no spheres are intersected. TYPE: Optional [ int ] Source code in napari_threedee/utils/selection_utils.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def select_sphere_from_click ( click_point : np . ndarray , view_direction : np . ndarray , sphere_centroids : np . ndarray , sphere_diameter : float ) -> Optional [ int ]: \"\"\"Determine which, if any spheres are intersected by a click ray. If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned. Parameters ---------- click_point : np.ndarray The point where the click ray originates. view_direction : np.ndarray The unit vector pointing in the direction the viewer is looking. sphere_centroids : np.ndarray The (n, 3) array of center points for the n points. sphere_diameter : float The diameter of all spheres. Must the same diameter for all spheres. Returns ------- selection : Optional[int] The index for the sphere that was intersected. Returns None if no spheres are intersected. \"\"\" # project the in view points onto the camera plane projected_points , projection_distances = project_points_onto_plane ( points = sphere_centroids , plane_point = click_point , plane_normal = view_direction , ) # rotate points and plane to be axis aligned with normal [0, 0, 1] rotated_points , rotation_matrix = rotate_points ( points = projected_points , current_plane_normal = view_direction , new_plane_normal = [ 0 , 0 , 1 ], ) rotated_click_point = np . dot ( rotation_matrix , click_point ) # find the points the click intersects n_spheres = len ( sphere_centroids ) handle_sizes = np . tile ( sphere_diameter , ( n_spheres , 1 )) distances = abs ( rotated_points [:, : 2 ] - rotated_click_point [: 2 ]) # the -1 accounts for the edge width in_slice_matches = np . all ( distances <= ( handle_sizes - 1 / 2 ) - 1.5 , axis = 1 , ) indices = np . where ( in_slice_matches )[ 0 ] if len ( indices ) > 0 : # find the point that is most in the foreground candidate_point_distances = projection_distances [ indices ] min_distance_index = np . argmin ( candidate_point_distances ) selection = indices [ min_distance_index ] else : selection = None return selection","title":"select_sphere_from_click()"},{"location":"annotations/io/","text":"Input/Output Annotation layers can be serialized to disk as n3d files. n3d files are zarr files . napari-threedee napari-threedee implements readers and writers for n3d files. Python n3d files can be opened in Python with the zarr library. import zarr n3d_data = zarr . load ( 'annotation.n3d' ) These objects contain some attributes allowing them to be correctly interpreted by napari-threedee . The attribute annotation_type maps to a specific reader function napari-threedee will use to load the data. n3d_data . attrs [ \"annotation_type\" ] Out[2]: 'spline' Other programming languages For working with n3d ( zarr ) files in other languages, please look at the zarr implementations repository .","title":"Input/Output"},{"location":"annotations/io/#inputoutput","text":"Annotation layers can be serialized to disk as n3d files. n3d files are zarr files .","title":"Input/Output"},{"location":"annotations/io/#napari-threedee","text":"napari-threedee implements readers and writers for n3d files.","title":"napari-threedee"},{"location":"annotations/io/#python","text":"n3d files can be opened in Python with the zarr library. import zarr n3d_data = zarr . load ( 'annotation.n3d' ) These objects contain some attributes allowing them to be correctly interpreted by napari-threedee . The attribute annotation_type maps to a specific reader function napari-threedee will use to load the data. n3d_data . attrs [ \"annotation_type\" ] Out[2]: 'spline'","title":"Python"},{"location":"annotations/io/#other-programming-languages","text":"For working with n3d ( zarr ) files in other languages, please look at the zarr implementations repository .","title":"Other programming languages"},{"location":"annotations/specifications/","text":"Overview Annotations made using the annotators from napari-threedee are stored on a single layer. This layer will match a specification for a given annotation type. Per-point attributes will be stored in the layer features table. Other metadata will be stored in the layer metadata as a dictionary under the \"n3d_metadata\" key. Specifications spline specification (points layer) sphere specification (points layer)","title":"Overview"},{"location":"annotations/specifications/#overview","text":"Annotations made using the annotators from napari-threedee are stored on a single layer. This layer will match a specification for a given annotation type. Per-point attributes will be stored in the layer features table. Other metadata will be stored in the layer metadata as a dictionary under the \"n3d_metadata\" key.","title":"Overview"},{"location":"annotations/specifications/#specifications","text":"spline specification (points layer) sphere specification (points layer)","title":"Specifications"},{"location":"annotations/sphere_spec/","text":"Sphere Specification Layer Specification Sphere annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain column called sphere_id , an integer id for each sphere. radius , a radius for each sphere. Zarr Array Specification The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'sphere.n3d' ) n3d is an (n, d) zarr.core.Array containing the center of each sphere n3d.attrs[\"annotation_type\"] is \"sphere\" n3d.attrs[\"sphere_id\"] is an (n, ) array containing a unique id for each sphere n3d.attrs[\"radius\"] is an (n, ) array containing the radius for each sphere","title":"Sphere Specification"},{"location":"annotations/sphere_spec/#sphere-specification","text":"","title":"Sphere Specification"},{"location":"annotations/sphere_spec/#layer-specification","text":"Sphere annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain column called sphere_id , an integer id for each sphere. radius , a radius for each sphere.","title":"Layer Specification"},{"location":"annotations/sphere_spec/#zarr-array-specification","text":"The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'sphere.n3d' ) n3d is an (n, d) zarr.core.Array containing the center of each sphere n3d.attrs[\"annotation_type\"] is \"sphere\" n3d.attrs[\"sphere_id\"] is an (n, ) array containing a unique id for each sphere n3d.attrs[\"radius\"] is an (n, ) array containing the radius for each sphere","title":"Zarr Array Specification"},{"location":"annotations/spline_spec/","text":"Spline Specification Layer Specification Spline annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain a column called spline_id , an integer id for each point. Points.metadata is a dictionary with the following key:value pairs \"spline_order\": int the order of the splines. Zarr Array Specification The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'spline.n3d' ) n3d is an (n, d) zarr.core.Array n3d.attrs[\"annotation_type\"] is \"spline\" n3d.attrs[\"spline_id\"] is an (n, ) array containing the spline id of each point n3d.attrs[\"spline_order\"] is the order of the splines as an integer","title":"Spline Specification"},{"location":"annotations/spline_spec/#spline-specification","text":"","title":"Spline Specification"},{"location":"annotations/spline_spec/#layer-specification","text":"Spline annotations are stored on a napari Points layer and can contain multiple splines. Points.data is an (n, d) array of n d-dimensional points. Points.features is a table which will contain a column called spline_id , an integer id for each point. Points.metadata is a dictionary with the following key:value pairs \"spline_order\": int the order of the splines.","title":"Layer Specification"},{"location":"annotations/spline_spec/#zarr-array-specification","text":"The following assumes an n3d file has been read into a variable called n3d using the zarr library import zarr zarr . load ( 'spline.n3d' ) n3d is an (n, d) zarr.core.Array n3d.attrs[\"annotation_type\"] is \"spline\" n3d.attrs[\"spline_id\"] is an (n, ) array containing the spline id of each point n3d.attrs[\"spline_order\"] is the order of the splines as an integer","title":"Zarr Array Specification"},{"location":"dev_guides/core_concepts/","text":"Core concepts napari-threedee provides reusable components (called threedee objects ) which - enable custom 3D interactive functionality - simplify the development of workflows with 3D interactivity How to use napari-threedee napari-threedee is designed to be used both as a napari plugin and as a library . When used as a plugin , a set of widgets provide custom 3D manipulation and annotation tools in napari. In this case, users need not delve into the code. For those who want to integrate custom 3D interactivity into their application, napari-threedee can also be used as a library . In this case, users can - integrate existing functionality into their applications - develop new custom functionality more easily threedee objects threedee objects can be split into two categories, manipulators and annotators . They can be activated and deactivated as required. Manipulators A Manipulator is an object in the scene which allows us to position something. It is a combination of translators and rotators . Clicking and dragging a translator will move the manipulator in the direction of the translator. Clicking and dragging a rotator will rotate the object. Manipulators can be used to modify other objects by providing callbacks which will be run before, during and after an interaction with the manipulator. For more details see manipulators Annotators An Annotator allows for a custom 3D data annotation mode in napari. This is particularly useful for orchestrating annotation behaviour which depends on the state of multiple layers (e.g. adding points on planes). Automatic widget generation A dock widget can be generated automatically for any threedee object by subclassing QtThreeDeeWidgetBase and providing the new threedee object as a model. class QtRenderPlaneManipulatorWidget ( QtThreeDeeWidgetBase ): def __init__ ( self , viewer : napari . Viewer , * args , ** kwargs ): super () . __init__ ( model = RenderPlaneManipulator , viewer = viewer , * args , ** kwargs )","title":"Core concepts"},{"location":"dev_guides/core_concepts/#core-concepts","text":"napari-threedee provides reusable components (called threedee objects ) which - enable custom 3D interactive functionality - simplify the development of workflows with 3D interactivity","title":"Core concepts"},{"location":"dev_guides/core_concepts/#how-to-use-napari-threedee","text":"napari-threedee is designed to be used both as a napari plugin and as a library . When used as a plugin , a set of widgets provide custom 3D manipulation and annotation tools in napari. In this case, users need not delve into the code. For those who want to integrate custom 3D interactivity into their application, napari-threedee can also be used as a library . In this case, users can - integrate existing functionality into their applications - develop new custom functionality more easily","title":"How to use napari-threedee"},{"location":"dev_guides/core_concepts/#threedee-objects","text":"threedee objects can be split into two categories, manipulators and annotators . They can be activated and deactivated as required.","title":"threedee objects"},{"location":"dev_guides/core_concepts/#manipulators","text":"A Manipulator is an object in the scene which allows us to position something. It is a combination of translators and rotators . Clicking and dragging a translator will move the manipulator in the direction of the translator. Clicking and dragging a rotator will rotate the object. Manipulators can be used to modify other objects by providing callbacks which will be run before, during and after an interaction with the manipulator. For more details see manipulators","title":"Manipulators"},{"location":"dev_guides/core_concepts/#annotators","text":"An Annotator allows for a custom 3D data annotation mode in napari. This is particularly useful for orchestrating annotation behaviour which depends on the state of multiple layers (e.g. adding points on planes).","title":"Annotators"},{"location":"dev_guides/core_concepts/#automatic-widget-generation","text":"A dock widget can be generated automatically for any threedee object by subclassing QtThreeDeeWidgetBase and providing the new threedee object as a model. class QtRenderPlaneManipulatorWidget ( QtThreeDeeWidgetBase ): def __init__ ( self , viewer : napari . Viewer , * args , ** kwargs ): super () . __init__ ( model = RenderPlaneManipulator , viewer = viewer , * args , ** kwargs )","title":"Automatic widget generation"},{"location":"dev_guides/manipulators/","text":"Manipulators Manipulators are UI elements attached to napari layers to aid with positioning and orienting layer data elements being displayed on the canvas. Manipulators can translate and rotate along/around specified axes. Coordinate system The manipulator coordinate system is defined with an affine transformation relative to the layer data coordinate system. The manipulator transformation is defined as a translation and a 3x3 transformation matrix (rotation and scale). The translation is stored in the manipulator.translation property and the transformation is stored in the manipulator. rot_mat property. The rotation is applied before the translation. Translators Translators are the UI element on the manipulator responsible for translating the manipulator. When the user clicks on a translator and drags it, the manipulator is translated by the drag vector component parallel to the translator direction. Translators are defined by unit vectors pointing in the direction of translation. The unit vectors are stored in the _initial_translator_normals property as an (n x 3) numpy array for n translators. One translator will be created for each unit vector in initial_translator_normals . Translator drag callback When a translator is dragged, the following callbacks are executed: _pre_drag() : This is called when the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_translator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the translator drag. _post_drag() : This is called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks. Implementing translators To add translators to a manipulator, the following must be implemented: _initial_translator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_translator() must be implemented. _post_drag() may be implemented. Rotators Rotators are the UI element on the manipulator responsible for rotating the manipulator. When the user clicks on a rotator and drags it, the manipulator is rotated around the normal vector of the rotator. Rotators are defined by unit vectors normal to the rotators. The unit vectors are stored in the _initial_rotators_normals property as an (n x 3) numpy array for n translators. One rotator will be created for each unit vector in initial_rotator_normals . Rotator drag callback When a rotator is dragged, the following callbacks are executed: _pre_drag() :This is called after the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_rotator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the rotator drag. _post_drag() : This is called called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks. Implementing rotators To add rotators to a manipulator, the following must be implemented: _initial_rotator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_rotator() must be implemented. _post_drag() may be implemented. Notes on performance In general, writing data to the GPU is slow compared to drawing the scene. Thus, it is recommended that for best performance, one should move the manipulator in the scene by modifying the transformation rather than modifying the manipulator definitions (i.e., _initial_translator_normals and _rotator_translator_normals )","title":"Manipulators"},{"location":"dev_guides/manipulators/#manipulators","text":"Manipulators are UI elements attached to napari layers to aid with positioning and orienting layer data elements being displayed on the canvas. Manipulators can translate and rotate along/around specified axes.","title":"Manipulators"},{"location":"dev_guides/manipulators/#coordinate-system","text":"The manipulator coordinate system is defined with an affine transformation relative to the layer data coordinate system. The manipulator transformation is defined as a translation and a 3x3 transformation matrix (rotation and scale). The translation is stored in the manipulator.translation property and the transformation is stored in the manipulator. rot_mat property. The rotation is applied before the translation.","title":"Coordinate system"},{"location":"dev_guides/manipulators/#translators","text":"Translators are the UI element on the manipulator responsible for translating the manipulator. When the user clicks on a translator and drags it, the manipulator is translated by the drag vector component parallel to the translator direction. Translators are defined by unit vectors pointing in the direction of translation. The unit vectors are stored in the _initial_translator_normals property as an (n x 3) numpy array for n translators. One translator will be created for each unit vector in initial_translator_normals .","title":"Translators"},{"location":"dev_guides/manipulators/#translator-drag-callback","text":"When a translator is dragged, the following callbacks are executed: _pre_drag() : This is called when the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_translator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the translator drag. _post_drag() : This is called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks.","title":"Translator drag callback"},{"location":"dev_guides/manipulators/#implementing-translators","text":"To add translators to a manipulator, the following must be implemented: _initial_translator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_translator() must be implemented. _post_drag() may be implemented.","title":"Implementing translators"},{"location":"dev_guides/manipulators/#rotators","text":"Rotators are the UI element on the manipulator responsible for rotating the manipulator. When the user clicks on a rotator and drags it, the manipulator is rotated around the normal vector of the rotator. Rotators are defined by unit vectors normal to the rotators. The unit vectors are stored in the _initial_rotators_normals property as an (n x 3) numpy array for n translators. One rotator will be created for each unit vector in initial_rotator_normals .","title":"Rotators"},{"location":"dev_guides/manipulators/#rotator-drag-callback","text":"When a rotator is dragged, the following callbacks are executed: _pre_drag() :This is called after the translator or rotator is clicked. This is typically used to set up for the drag callback. _while_dragging_rotator() : This is called during the drag and is typically used to update layer or manipulator attributes in response to the rotator drag. _post_drag() : This is called called after the drag has finished. This is generally used to clean up any variables that were set during the drag or pre drag callbacks.","title":"Rotator drag callback"},{"location":"dev_guides/manipulators/#implementing-rotators","text":"To add rotators to a manipulator, the following must be implemented: _initial_rotator_normals must be defined in the __init__() method. _pre_drag() callback may be implemented. _while_dragging_rotator() must be implemented. _post_drag() may be implemented.","title":"Implementing rotators"},{"location":"dev_guides/manipulators/#notes-on-performance","text":"In general, writing data to the GPU is slow compared to drawing the scene. Thus, it is recommended that for best performance, one should move the manipulator in the scene by modifying the transformation rather than modifying the manipulator definitions (i.e., _initial_translator_normals and _rotator_translator_normals )","title":"Notes on performance"},{"location":"getting_started/developers/","text":"Geting started for developers Explanations of the core concepts and manipulators. Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"for developers"},{"location":"getting_started/developers/#geting-started-for-developers","text":"Explanations of the core concepts and manipulators. Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"Geting started for developers"},{"location":"getting_started/users/","text":"Getting started for users Tutorials Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"for users"},{"location":"getting_started/users/#getting-started-for-users","text":"Tutorials Gallery of examples of plugins that depend on napari-threedee (WIP).","title":"Getting started for users"},{"location":"how_to/how_to_render_plane_manipulator/","text":"use the render plane manipulator Summary This article explains how to use the render plane manipulator. The","title":"use the render plane manipulator"},{"location":"how_to/how_to_render_plane_manipulator/#use-the-render-plane-manipulator","text":"","title":"use the render plane manipulator"},{"location":"how_to/how_to_render_plane_manipulator/#summary","text":"This article explains how to use the render plane manipulator. The","title":"Summary"},{"location":"tutorials/tutorials/","text":"Tutorials","title":"Tutorials"},{"location":"tutorials/tutorials/#tutorials","text":"","title":"Tutorials"}]}