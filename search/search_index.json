{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>napari-threedee is a collection of tools for exploring, manipulating, and annotating your data in 3D. </p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p><code>napari-threedee</code> is a <code>napari</code> plugin and thus requires <code>napari</code> to work. You can see the <code>napari</code> documentation for  napari installation instructions. After you  have installed <code>napari</code>, you can install <code>napari-threedee</code> using the package manager of your choice using the commands  below.</p> pipconda <pre><code>pip install napari-threedee\n</code></pre> <pre><code>conda install -c conda-forge napari-threedee\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#users","title":"Users","text":"<p>Do you have rich 3D (or more!) data that you want to explore and annotate? <code>napari-threedee</code> comes with a collection  of plugins for just that. Please see our Getting started for users guide to get going.</p>"},{"location":"#developers","title":"Developers","text":"<p>Are you developing an image processing workflow that requires exploration or annotation of multidimensional data?  <code>napari-threedee</code> has a collection of composable compoents for adding 3D interactivity to your workflow! To get  started, see our Getting started for developers guide.</p>"},{"location":"API/geometry_utilities/","title":"Geometry utilities","text":""},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry","title":"<code>napari_threedee.utils.geometry</code>","text":""},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.signed_angle_between_vectors","title":"<code>signed_angle_between_vectors(vector_0, vector_1, rotation_axis: np.ndarray) -&gt; float</code>","text":"<p>Returns the angle in radians between vectors 'v1' and 'v2'.</p> PARAMETER DESCRIPTION <code>vector_0</code> <p>The vector to start the rotation at.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>vector_1</code> <p>The vector the rotation ends at.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>rotation_axis</code> <p>The axis around which the rotation is occuring. Must be orthogonal to vector_0 and vector_1.</p> <p> TYPE: <code>np.ndarray</code> </p> RETURNS DESCRIPTION <code>angle</code> <p>The signed angle of rotation in radians.</p> <p> TYPE: <code>float</code> </p> Source code in <code>napari_threedee/utils/geometry.py</code> <pre><code>def signed_angle_between_vectors(vector_0, vector_1, rotation_axis: np.ndarray) -&gt; float:\n\"\"\" Returns the angle in radians between vectors 'v1' and 'v2'.\n\n    Parameters\n    ----------\n    vector_0 : np.ndarray\n        The vector to start the rotation at.\n    vector_1 : np.ndarray\n        The vector the rotation ends at.\n    rotation_axis : np.ndarray\n        The axis around which the rotation is occuring.\n        Must be orthogonal to vector_0 and vector_1.\n\n    Returns\n    -------\n    angle : float\n        The signed angle of rotation in radians.\n    \"\"\"\n    unit_vector_0 = vector_0 / np.linalg.norm(vector_0)\n    unit_vector_1 = vector_1 / np.linalg.norm(vector_1)\n\n    unsigned_angle = np.arccos(np.clip(np.dot(unit_vector_0, unit_vector_1), -1.0, 1.0))\n\n    v3 = np.cross(unit_vector_0, unit_vector_1)\n\n    angle_sign = -1 if np.dot(v3, rotation_axis) &lt; 0 else 1\n\n    return angle_sign * unsigned_angle\n</code></pre>"},{"location":"API/geometry_utilities/#napari_threedee.utils.geometry.rotation_matrix_around_vector_3d","title":"<code>rotation_matrix_around_vector_3d(angle: float, vector: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Create the rotation matrix for a specified angle of rotation around a vector.</p> PARAMETER DESCRIPTION <code>angle</code> <p>The signed angle of rotation in radians.</p> <p> TYPE: <code>float</code> </p> <p>vector : np.ndarray     The vector around which to perform the rotation.</p> RETURNS DESCRIPTION <code>rotation_matrix</code> <p>(3, 3) rotation matrix for the specified rotation.</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>napari_threedee/utils/geometry.py</code> <pre><code>def rotation_matrix_around_vector_3d(angle: float, vector: np.ndarray) -&gt; np.ndarray:\n\"\"\"Create the rotation matrix for a specified angle of rotation around a vector.\n\n    Parameters\n    ----------\n    angle : float\n        The signed angle of rotation in radians.\n\n    vector : np.ndarray\n        The vector around which to perform the rotation.\n\n    Returns\n    -------\n    rotation_matrix : np.ndarray\n        (3, 3) rotation matrix for the specified rotation.\n    \"\"\"\n    vector_u = vector / np.linalg.norm(vector)\n    u_0 = vector_u[0]\n    u_1 = vector_u[1]\n    u_2 = vector_u[2]\n\n    cos_term = 1 - np.cos(angle)\n    sine_term = np.sin(angle)\n\n    rotation_matrix = np.zeros((3, 3))\n    rotation_matrix[0, 0] = np.cos(angle) + (u_0**2) * cos_term\n    rotation_matrix[0, 1] = (u_0 * u_1 * cos_term) - u_2 * sine_term\n    rotation_matrix[0, 2] = (u_0 * u_2 * cos_term) + u_1 * sine_term\n\n    rotation_matrix[1, 0] = (u_1 * u_0 * cos_term) + u_2 * sine_term\n    rotation_matrix[1, 1] = np.cos(angle) + (u_1**2) * cos_term\n    rotation_matrix[1, 2] = (u_1 * u_2 * cos_term) - u_0 * sine_term\n\n    rotation_matrix[2, 0] = (u_0 * u_2 * cos_term) - u_1 * sine_term\n    rotation_matrix[2, 1] = u_1 * u_2 * cos_term + u_0 * sine_term\n    rotation_matrix[2, 2] = np.cos(angle) + (u_2**2) * cos_term\n\n    return rotation_matrix\n</code></pre>"},{"location":"API/napari_utilities/","title":"napari utilities","text":""},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils","title":"<code>napari_threedee.utils.napari_utils</code>","text":""},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_napari_visual","title":"<code>get_napari_visual(viewer, layer)</code>","text":"<p>Get the visual class for a given layer</p> PARAMETER DESCRIPTION <code>viewer</code> <p>The napari viewer object</p> <p> </p> <code>layer</code> <p>The napari layer object for which to find the visual.</p> <p> </p> RETURNS DESCRIPTION <code>visual</code> <p>The napari visual class for the layer.</p> Source code in <code>napari_threedee/utils/napari_utils.py</code> <pre><code>def get_napari_visual(viewer, layer):\n\"\"\"Get the visual class for a given layer\n\n    Parameters\n    ----------\n    viewer\n        The napari viewer object\n    layer\n        The napari layer object for which to find the visual.\n\n    Returns\n    -------\n    visual\n        The napari visual class for the layer.\n    \"\"\"\n    visual = viewer.window._qt_window._qt_viewer.layer_to_visual[layer]\n\n    return visual\n</code></pre>"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_dimensions","title":"<code>get_mouse_position_in_displayed_dimensions(event) -&gt; np.ndarray</code>","text":"<p>Get the position under the mouse in scene (displayed world) coordinates.</p> PARAMETER DESCRIPTION <code>event</code> <p>The mouse event.</p> <p> </p> RETURNS DESCRIPTION <code>click_dir_data_3d</code> <p>The click direction in displayed data coordiantes</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>napari_threedee/utils/napari_utils.py</code> <pre><code>def get_mouse_position_in_displayed_dimensions(event) -&gt; np.ndarray:\n\"\"\"Get the position under the mouse in scene (displayed world) coordinates.\n\n    Parameters\n    ----------\n    event\n        The mouse event.\n\n    Returns\n    -------\n    click_dir_data_3d : np.ndarray\n        The click direction in displayed data coordiantes\n    \"\"\"\n    click_position_world = event.position\n    return np.asarray(click_position_world)[list(event.dims_displayed)]\n</code></pre>"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_view_direction_in_displayed_dimensions","title":"<code>get_view_direction_in_displayed_dimensions(event) -&gt; np.ndarray</code>","text":"<p>Get the view direction under the mouse in scene (displayed world) coordinates.</p> PARAMETER DESCRIPTION <code>event</code> <p>napari mouse event.</p> <p> </p> Source code in <code>napari_threedee/utils/napari_utils.py</code> <pre><code>def get_view_direction_in_displayed_dimensions(event) -&gt; np.ndarray:\n\"\"\"Get the view direction under the mouse in scene (displayed world) coordinates.\n\n    Parameters\n    ----------\n    event: Event\n        napari mouse event.\n    \"\"\"\n    view_direction_world = event.view_direction\n    return np.asarray(view_direction_world)[list(event.dims_displayed)]\n</code></pre>"},{"location":"API/napari_utilities/#napari_threedee.utils.napari_utils.get_mouse_position_in_displayed_layer_data_coordinates","title":"<code>get_mouse_position_in_displayed_layer_data_coordinates(layer, event) -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>Get the mouse click position and direction in layer data displayed coordinates.</p> PARAMETER DESCRIPTION <code>layer</code> <p>The layer to convert the coordinates to.</p> <p> TYPE: <code>napari.layers.Layer</code> </p> <code>event</code> <p>The mouse event.</p> <p> </p> RETURNS DESCRIPTION <code>click_position_data_3d</code> <p>The click position in displayed data coordinates.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>click_dir_data_3d</code> <p>The click direction in displayed data coordiantes</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>napari_threedee/utils/napari_utils.py</code> <pre><code>def get_mouse_position_in_displayed_layer_data_coordinates(layer, event) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"Get the mouse click position and direction in layer data displayed coordinates.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        The layer to convert the coordinates to.\n    event\n        The mouse event.\n\n    Returns\n    -------\n    click_position_data_3d : np.ndarray\n        The click position in displayed data coordinates.\n    click_dir_data_3d : np.ndarray\n        The click direction in displayed data coordiantes\n    \"\"\"\n    click_position_world = event.position\n    click_position_data_3d = np.asarray(\n        layer._world_to_displayed_data(\n            click_position_world,\n            event.dims_displayed\n        )\n    )\n    click_dir_data_3d = np.asarray(\n        layer._world_to_displayed_data_ray(\n            event.view_direction,\n            event.dims_displayed\n        )\n    )\n\n    return click_position_data_3d, click_dir_data_3d\n</code></pre>"},{"location":"API/selection_utilities/","title":"Selection utilities","text":""},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils","title":"<code>napari_threedee.utils.selection_utils</code>","text":""},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.distance_between_point_and_line_segment_2d","title":"<code>distance_between_point_and_line_segment_2d(p, p1, p2)</code>","text":"<p>Calculate the distance between a point p and a line segment p1, p2</p> Source code in <code>napari_threedee/utils/selection_utils.py</code> <pre><code>def distance_between_point_and_line_segment_2d(p, p1, p2):\n\"\"\"Calculate the distance between a point p and a line segment p1, p2\n    \"\"\"\n    x0 = p[0]\n    y0 = p[1]\n    x1 = p1[0]\n    y1 = p1[1]\n    x2 = p2[0]\n    y2 = p2[1]\n\n    numerator = np.linalg.norm((x2 - x1) * (y1 - y0) - (x1 - x0) * (y2 - y1))\n    denominator = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    return numerator / denominator\n</code></pre>"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_triangle_from_click","title":"<code>select_triangle_from_click(click_point: np.ndarray, view_direction: np.ndarray, triangles: np.ndarray)</code>","text":"<p>Determine if a line goes through any of a set of triangles.</p> <p>For example, this could be used to determine if a click was in a triangle of a mesh.</p> PARAMETER DESCRIPTION <code>click_point</code> <p>(3,) array containing the location that was clicked. This should be in the same coordinate system as the vertices.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>view_direction</code> <p>(3,) array describing the direction camera is pointing in the scene. This should be in the same coordinate system as the vertices.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>triangles</code> <p>(n, 3, 3) array containing the coordinates for the 3 corners of n triangles.</p> <p> TYPE: <code>np.ndarray</code> </p> RETURNS DESCRIPTION <code>in_triangles</code> <p>(n,) boolean array that is True of the ray intersects the triangle</p> <p> TYPE: <code>np.ndarray</code> </p> Source code in <code>napari_threedee/utils/selection_utils.py</code> <pre><code>def select_triangle_from_click(\n        click_point: np.ndarray, view_direction: np.ndarray, triangles: np.ndarray\n):\n\"\"\"Determine if a line goes through any of a set of triangles.\n\n    For example, this could be used to determine if a click was\n    in a triangle of a mesh.\n\n    Parameters\n    ----------\n    click_point : np.ndarray\n        (3,) array containing the location that was clicked. This\n        should be in the same coordinate system as the vertices.\n    view_direction : np.ndarray\n        (3,) array describing the direction camera is pointing in\n        the scene. This should be in the same coordinate system as\n        the vertices.\n    triangles : np.ndarray\n        (n, 3, 3) array containing the coordinates for the 3 corners\n        of n triangles.\n\n    Returns\n    -------\n    in_triangles : np.ndarray\n        (n,) boolean array that is True of the ray intersects the triangle\n    \"\"\"\n    vertices = triangles.reshape((-1, triangles.shape[2]))\n    # project the vertices of the bound region on to the view plane\n    vertices_plane, signed_distance_to_plane = project_points_onto_plane(\n        points=vertices, plane_point=click_point, plane_normal=view_direction\n    )\n\n    # rotate the plane to make the triangles 2D\n    rotation_matrix = rotation_matrix_from_vectors_3d(view_direction, [0, 0, 1])\n    rotated_vertices = vertices_plane @ rotation_matrix.T\n\n    rotated_vertices_2d = rotated_vertices[:, :2]\n    rotated_triangles_2d = rotated_vertices_2d.reshape(-1, 3, 2)\n    line_pos_2D = rotation_matrix.dot(click_point)[:2]\n\n    candidate_matches = inside_triangles(rotated_triangles_2d - line_pos_2D)\n\n    candidate_match_indices = np.argwhere(candidate_matches)\n\n    n_matches = len(candidate_match_indices)\n    if n_matches == 0:\n        triangle_index = None\n    elif n_matches == 1:\n        triangle_index = candidate_match_indices[0]\n    else:\n        potential_match_distances = signed_distance_to_plane[candidate_match_indices]\n        triangle_index = candidate_match_indices[np.argmin(potential_match_distances)]\n\n    return triangle_index\n</code></pre>"},{"location":"API/selection_utilities/#napari_threedee.utils.selection_utils.select_sphere_from_click","title":"<code>select_sphere_from_click(click_point: np.ndarray, view_direction: np.ndarray, sphere_centroids: np.ndarray, sphere_diameter: float) -&gt; Optional[int]</code>","text":"<p>Determine which, if any spheres are intersected by a click ray.</p> <p>If multiple spheres are intersected, the closest sphere to the click point (ray start) will be returned.</p> PARAMETER DESCRIPTION <code>click_point</code> <p>The point where the click ray originates.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>view_direction</code> <p>The unit vector pointing in the direction the viewer is looking.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>sphere_centroids</code> <p>The (n, 3) array of center points for the n points.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>sphere_diameter</code> <p>The diameter of all spheres. Must the same diameter for all spheres.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>selection</code> <p>The index for the sphere that was intersected. Returns None if no spheres are intersected.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>napari_threedee/utils/selection_utils.py</code> <pre><code>def select_sphere_from_click(\n    click_point: np.ndarray, view_direction: np.ndarray, sphere_centroids: np.ndarray, sphere_diameter: float\n) -&gt; Optional[int]:\n\"\"\"Determine which, if any spheres are intersected by a click ray.\n\n    If multiple spheres are intersected, the closest sphere to the click point\n    (ray start) will be returned.\n\n    Parameters\n    ----------\n    click_point : np.ndarray\n        The point where the click ray originates.\n    view_direction : np.ndarray\n        The unit vector pointing in the direction the viewer is looking.\n    sphere_centroids : np.ndarray\n        The (n, 3) array of center points for the n points.\n    sphere_diameter : float\n        The diameter of all spheres. Must the same diameter for all spheres.\n\n    Returns\n    -------\n    selection : Optional[int]\n        The index for the sphere that was intersected.\n        Returns None if no spheres are intersected.\n    \"\"\"\n    # project the in view points onto the camera plane\n    projected_points, projection_distances = project_points_onto_plane(\n        points=sphere_centroids,\n        plane_point=click_point,\n        plane_normal=view_direction,\n    )\n\n    # rotate points and plane to be axis aligned with normal [0, 0, 1]\n    rotated_points, rotation_matrix = rotate_points(\n        points=projected_points,\n        current_plane_normal=view_direction,\n        new_plane_normal=[0, 0, 1],\n    )\n    rotated_click_point = np.dot(rotation_matrix, click_point)\n\n    # find the points the click intersects\n    n_spheres = len(sphere_centroids)\n    handle_sizes = np.tile(sphere_diameter, (n_spheres, 1))\n    distances = abs(rotated_points[:, :2] - rotated_click_point[:2])\n\n    # the -1 accounts for the edge width\n    in_slice_matches = np.all(\n        distances &lt;= (handle_sizes - 1 / 2) - 1.5,\n        axis=1,\n    )\n    indices = np.where(in_slice_matches)[0]\n\n    if len(indices) &gt; 0:\n        # find the point that is most in the foreground\n        candidate_point_distances = projection_distances[indices]\n        min_distance_index = np.argmin(candidate_point_distances)\n        selection = indices[min_distance_index]\n    else:\n        selection = None\n\n    return selection\n</code></pre>"},{"location":"annotations/io/","title":"Input/Output","text":"<p>Annotation layers can be serialized to disk as <code>n3d</code> files. <code>n3d</code> files are <code>zarr</code> files.</p>"},{"location":"annotations/io/#napari-threedee","title":"napari-threedee","text":"<p>napari-threedee implements readers and writers for <code>n3d</code> files.</p>"},{"location":"annotations/io/#python","title":"Python","text":"<p><code>n3d</code> files can be opened in Python with the  zarr  library.</p> <pre><code>import zarr\n\nn3d_data = zarr.load('annotation.n3d')\n</code></pre> <p>These objects contain some attributes allowing them to be  correctly interpreted by napari-threedee. The  attribute <code>annotation_type</code> maps to a specific reader function  napari-threedee will use to load the data.</p> <p><pre><code>n3d_data.attrs[\"annotation_type\"]\n</code></pre> <pre><code>Out[2]: 'spline'\n</code></pre></p>"},{"location":"annotations/io/#other-programming-languages","title":"Other programming languages","text":"<p>For working with <code>n3d</code> (<code>zarr</code>) files in other languages, please look at the  zarr implementations repository.</p>"},{"location":"annotations/point_spec/","title":"Point Specification","text":""},{"location":"annotations/point_spec/#layer-specification","title":"Layer Specification","text":"<p>Point annotations are stored on a napari  <code>Points</code> layer.</p> <ul> <li><code>Points.data</code> is an <code>(n, d)</code> array of n d-dimensional points.</li> <li><code>Points.metadata[\"n3d_metadata\"]</code> is a dictionary with the following    key/value pairs</li> <li><code>annotation_type</code>: <code>point</code></li> </ul>"},{"location":"annotations/point_spec/#zarr-array-specification","title":"Zarr Array Specification","text":"<p>The following assumes an <code>n3d</code> file has been read into a variable called  <code>n3d</code> using the zarr library</p> <pre><code>import zarr\n\nzarr.load('points.n3d')\n</code></pre> <ul> <li><code>n3d</code> is an <code>(n, d)</code> <code>zarr.core.Array</code> containing the points</li> <li><code>n3d.attrs[\"annotation_type\"]</code> is <code>\"sphere\"</code></li> </ul>"},{"location":"annotations/specifications/","title":"Overview","text":"<p>Annotations made using the annotators from napari-threedee are stored  on a single layer. This layer will match a specification for a given annotation type.</p> <p>Per-point attributes will be stored in the layer features table. Other  metadata will be stored in the layer metadata as a dictionary under the  <code>\"n3d_metadata\"</code> key.</p>"},{"location":"annotations/specifications/#specifications","title":"Specifications","text":"<ul> <li>spline specification (points layer)</li> <li>sphere specification (points layer)</li> </ul>"},{"location":"annotations/sphere_spec/","title":"Sphere Specification","text":""},{"location":"annotations/sphere_spec/#layer-specification","title":"Layer Specification","text":"<p>Sphere annotations are stored on a napari  <code>Points</code> layer and  can contain multiple splines.</p> <ul> <li><code>Points.data</code> is an <code>(n, d)</code> array of n d-dimensional points.</li> <li><code>Points.features</code> is a table which will contain column called <ul> <li><code>sphere_id</code>, an integer id for each sphere.</li> <li><code>radius</code>, a radius for each sphere.</li> </ul> </li> <li><code>Points.metadata[\"n3d_metadata\"]</code> is a dictionary with the following    key/value pairs</li> <li><code>annotation_type</code>: <code>sphere</code></li> </ul>"},{"location":"annotations/sphere_spec/#zarr-array-specification","title":"Zarr Array Specification","text":"<p>The following assumes an <code>n3d</code> file has been read into a variable called  <code>n3d</code> using the zarr library</p> <pre><code>import zarr\n\nzarr.load('sphere.n3d')\n</code></pre> <ul> <li><code>n3d</code> is an <code>(n, d)</code> <code>zarr.core.Array</code> containing the center of each sphere</li> <li><code>n3d.attrs[\"annotation_type\"]</code> is <code>\"sphere\"</code></li> <li><code>n3d.attrs[\"sphere_id\"]</code> is an <code>(n, )</code> array containing a unique id for    each sphere</li> <li><code>n3d.attrs[\"radius\"]</code> is an <code>(n, )</code> array containing the radius for each    sphere</li> </ul>"},{"location":"annotations/spline_spec/","title":"Spline Specification","text":""},{"location":"annotations/spline_spec/#layer-specification","title":"Layer Specification","text":"<p>Spline annotations are stored on a napari  <code>Points</code> layer and  can contain multiple splines.</p> <ul> <li><code>Points.data</code> is an <code>(n, d)</code> array of n d-dimensional points.</li> <li><code>Points.features</code> is a table which will contain a column called    <code>spline_id</code>, an integer id for each point.</li> <li><code>Points.metadata[\"n3d_metadata\"]</code> is a dictionary with the following    key/value pairs</li> <li><code>annotation_type</code>: <code>spline</code></li> </ul>"},{"location":"annotations/spline_spec/#zarr-array-specification","title":"Zarr Array Specification","text":"<p>The following assumes an <code>n3d</code> file has been read into a variable called  <code>n3d</code> using the zarr library</p> <pre><code>import zarr\n\nzarr.load('spline.n3d')\n</code></pre> <ul> <li><code>n3d</code> is an <code>(n, d)</code> <code>zarr.core.Array</code></li> <li><code>n3d.attrs[\"annotation_type\"]</code> is <code>\"spline\"</code></li> <li><code>n3d.attrs[\"spline_id\"]</code> is an <code>(n, )</code> array containing the spline id of    each point</li> </ul>"},{"location":"dev_guides/core_concepts/","title":"Core concepts","text":"<p><code>napari-threedee</code> provides reusable components (called <code>threedee</code> objects) which  - enable custom 3D interactive functionality - simplify the development of workflows with 3D interactivity</p>"},{"location":"dev_guides/core_concepts/#how-to-use-napari-threedee","title":"How to use <code>napari-threedee</code>","text":"<p><code>napari-threedee</code> is designed to be used both as a napari plugin and as a library.</p> <p>When used as a plugin, a set of widgets provide custom 3D manipulation and  annotation tools in napari. In this case, users need not delve into the code.</p> <p>For those who want to integrate custom 3D interactivity into their application,  <code>napari-threedee</code> can also be used as a library. In this case, users can - integrate existing functionality into their applications - develop new custom functionality more easily</p>"},{"location":"dev_guides/core_concepts/#threedee-objects","title":"<code>threedee</code> objects","text":"<p><code>threedee</code> objects can be split into two categories, manipulators and annotators. They can be activated and deactivated as required.</p>"},{"location":"dev_guides/core_concepts/#manipulators","title":"Manipulators","text":"<p>A Manipulator is an object in the scene which allows us to position something.  It is a combination of translators and rotators. </p> <p>Clicking and dragging a translator will move the manipulator in the direction of the translator. Clicking and dragging a rotator will rotate the object.</p> <p>Manipulators can be used to modify other objects by providing callbacks which will  be run before, during and after an interaction with the manipulator. </p> <p>For more details see manipulators</p>"},{"location":"dev_guides/core_concepts/#annotators","title":"Annotators","text":"<p>An Annotator allows for a custom 3D data annotation mode in napari.  This is particularly useful for orchestrating annotation behaviour which depends  on the state of multiple layers (e.g. adding points on planes).</p>"},{"location":"dev_guides/core_concepts/#automatic-widget-generation","title":"Automatic widget generation","text":"<p>A dock widget can be generated automatically for any <code>threedee</code> object by subclassing <code>QtThreeDeeWidgetBase</code> and providing the new <code>threedee</code> object as a model.</p> <pre><code>class QtRenderPlaneManipulatorWidget(QtThreeDeeWidgetBase):\n    def __init__(self,viewer: napari.Viewer, *args, **kwargs):\n        super().__init__(model=RenderPlaneManipulator, viewer=viewer, *args, **kwargs)\n</code></pre>"},{"location":"dev_guides/manipulators/","title":"Manipulators","text":"<p>Manipulators are UI elements attached to napari layers to aid with positioning and orienting layer data elements  being displayed on the canvas. Manipulators can translate and rotate along/around specified axes.</p>"},{"location":"dev_guides/manipulators/#coordinate-system","title":"Coordinate system","text":"<p>The manipulator coordinate system is defined with an affine transformation relative to the layer data coordinate system. The manipulator transformation is defined as a translation and a 3x3 transformation matrix (rotation and scale). The  translation is stored in the <code>manipulator.translation</code> property and the transformation is stored in the <code>manipulator. rot_mat</code> property. The rotation is applied before the translation. </p>"},{"location":"dev_guides/manipulators/#translators","title":"Translators","text":"<p>Translators are the UI element on the manipulator responsible for translating the manipulator. When the user  clicks on a translator and drags it, the manipulator is translated by the drag vector component parallel to the  translator direction. </p> <p>Translators are defined by unit vectors pointing in the direction of translation. The unit vectors are stored in the  <code>_initial_translator_normals</code> property as an (n x 3) numpy array for n translators. One translator will be created  for each unit vector in <code>initial_translator_normals</code>.</p>"},{"location":"dev_guides/manipulators/#translator-drag-callback","title":"Translator drag callback","text":"<p>When a translator is dragged, the following callbacks are executed:</p> <ol> <li><code>_pre_drag()</code>: This is called when the translator or rotator is clicked. This is typically used to set up for the     drag callback.</li> <li><code>_while_dragging_translator()</code>: This is called during the drag and is typically used to update layer or manipulator     attributes in response to the translator drag. </li> <li><code>_post_drag()</code>: This is called after the drag has finished. This is generally used to clean up any     variables that were set during the drag or pre drag callbacks.</li> </ol>"},{"location":"dev_guides/manipulators/#implementing-translators","title":"Implementing translators","text":"<p>To add translators to a manipulator, the following must be implemented:</p> <ul> <li><code>_initial_translator_normals</code> must be defined in the <code>__init__()</code> method.</li> <li><code>_pre_drag()</code> callback may be implemented.</li> <li><code>_while_dragging_translator()</code> must be implemented.</li> <li><code>_post_drag()</code> may be implemented.</li> </ul>"},{"location":"dev_guides/manipulators/#rotators","title":"Rotators","text":"<p>Rotators are the UI element on the manipulator responsible for rotating the manipulator. When the user  clicks on a rotator and drags it, the manipulator is rotated around the normal vector of the rotator.</p> <p>Rotators are defined by unit vectors normal to the rotators. The unit vectors are stored in the  <code>_initial_rotators_normals</code> property as an (n x 3) numpy array for n translators. One rotator will be created  for each unit vector in <code>initial_rotator_normals</code>.</p>"},{"location":"dev_guides/manipulators/#rotator-drag-callback","title":"Rotator drag callback","text":"<p>When a rotator is dragged, the following callbacks are executed:</p> <ol> <li><code>_pre_drag()</code>:This is called after the translator or rotator is clicked. This is typically used to set up for the     drag callback.</li> <li><code>_while_dragging_rotator()</code>: This is called during the drag and is typically used to update layer or manipulator     attributes in response to the rotator drag. </li> <li><code>_post_drag()</code>: This is called called after the drag has finished. This is generally used to clean up any     variables that were set during the drag or pre drag callbacks.</li> </ol>"},{"location":"dev_guides/manipulators/#implementing-rotators","title":"Implementing rotators","text":"<p>To add rotators to a manipulator, the following must be implemented:</p> <ul> <li><code>_initial_rotator_normals</code> must be defined in the <code>__init__()</code> method.</li> <li><code>_pre_drag()</code> callback may be implemented.</li> <li><code>_while_dragging_rotator()</code> must be implemented.</li> <li><code>_post_drag()</code> may be implemented.</li> </ul>"},{"location":"dev_guides/manipulators/#notes-on-performance","title":"Notes on performance","text":"<p>In general, writing data to the GPU is slow compared to drawing the scene. Thus, it is recommended that for best  performance, one should move the manipulator in the scene by modifying the transformation rather than modifying the  manipulator definitions (i.e., <code>_initial_translator_normals</code> and <code>_rotator_translator_normals</code>)</p>"},{"location":"getting_started/developers/","title":"Geting started for developers","text":"<ul> <li>Explanations of the core concepts and manipulators.</li> <li>Gallery of examples of plugins that depend on <code>napari-threedee</code>(WIP).</li> </ul>"},{"location":"getting_started/users/","title":"Getting started for users","text":"<ul> <li>Tutorials</li> <li>Gallery of examples of plugins that depend on <code>napari-threedee</code> (WIP).</li> </ul>"},{"location":"how_to/layer_manipulator/","title":"How to position layers with the layer manipulator","text":""},{"location":"how_to/layer_manipulator/#summary","title":"Summary","text":"<p>Sometimes objects in your data have a systematic shift relative to one another. If you need to position an entire dataset, you can use the layer manipulator. This article describes how to interactively position a layer using the layer manipulator.</p> <p></p>"},{"location":"how_to/layer_manipulator/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the layer_manipulator.py example from the docs. The viewer is initalized in 3D rendering mode. You can click and drag in the canvas to rotate the view. Note that the two layers are the same image, but not aligned.</p> <p></p> </li> <li> <p>Select the \"image_1\" layer in the layer manipulator plugin. We will move layer \"image_1\" (the green one) to be aligned with layer \"image_0\".</p> <p></p> </li> <li> <p>Activate the layer manipulator plugin.</p> <p></p> <p>When the plugin is activated, you will see the manipulator at (0, 0, 0) on image_1.</p> <p></p> </li> <li> <p>Click and drag the manipulator to align the rows. Since the layers are being rendered with additive blending, the image turns white where the layers are overlapping.</p> <p></p> </li> </ol>"},{"location":"how_to/point_manipulator/","title":"How to position points with the point manipulator","text":""},{"location":"how_to/point_manipulator/#summary","title":"Summary","text":"<p>Precisely positioning a point in 3D is a useful way to annotate specific positions or choose the location of an object in a scene. This article explains how to use the <code>napari-threedee</code> point manipulator plugin to position points in 3D.</p> <p></p>"},{"location":"how_to/point_manipulator/#instructions","title":"Instructions","text":"<ol> <li> <p>Open the points_manipulator.py example.</p> <p>    The example opens in 3D rendering mode. Click and drag to rotate the view.</p> </li> <li> <p>Open the point manipulator plugin from the Plugins menu: Plugins -&gt; napari-threedee -&gt; point manipulator. Click the \"activate\" to start the plugin.</p> <p></p> </li> <li> <p>Set the Points later to \"Selection\" mode by clicking the \"Selection\" button in the layer controls</p> <p></p> </li> <li> <p>Select a point by clicking on it. The point manipulator will appear on the selected point.</p> <p></p> </li> <li> <p>You can now move the point around by clicking and dragging the manipulator.</p> <p></p> <p>If you want to rotate the view while a point manipulator is active, press and hold the space bar while clicking and dragging in the canvas to rotate the view. The manipulator will be rendered invisible while you rotate so you can see the whole scene.</p> <p></p> </li> </ol>"},{"location":"how_to/render_plane_manipulator/","title":"How to use the render plane manipulator","text":""},{"location":"how_to/render_plane_manipulator/#summary","title":"Summary","text":"<p>The render plane manipulator allows you to interactively position the plane being visualized in the <code>napari</code> <code>Image</code>  layer plane depiction mode. The plane depiction mode is a 3D rendering mode where only the specified plane is  rendered. This is a power rendering mode for visualizing structures within a 3D volume, but defining the precise  plane programatically can be challenging. Thus, the render plane manipulator is useful for interactively positioning  the rendering plane.</p> <p></p>"},{"location":"how_to/render_plane_manipulator/#instructions","title":"Instructions","text":"<ol> <li> <p>Launch <code>napari</code>. Open your terminal and activate your <code>napari-threedee</code> environment. Enter <code>napari</code> in the     command prompt to launch napari.</p> <pre><code>napari\n</code></pre> </li> <li> <p>Load the \"HIV virus-like particles tomogram\" image from the File menu: File -&gt; Open Sample -&gt; HIV virus-like particle tomogram. Note that this will download the sample image so it make take some time. If you have previously opened the sample image, it should be cached and will not download again.</p> <p></p> </li> <li> <p>Click the \"Toggle ndisplay\" button in the lower left corner of the viewer to enter 3D rendering mode. </p> <p></p> <p>Upon clicking the button, you will see the volume in 3D. You you can click and drag to rotate the view. Note that the HIV particles are visible, but low contrast.</p> <p></p> </li> <li> <p>In the layer controls, change the <code>depiction</code> mode from <code>volume</code> to <code>plane</code>.</p> <p></p> <p>After changing the depiction mode, you will see a single plane being rendered from your 3d volume.</p> <p></p> </li> <li> <p>Open the render plane manipulator plugin from the menu: Plugins -&gt; napari-threedee -&gt; render plane manipulator. You will see the render plane manipulator appear on the rendering plane.</p> <p></p> </li> <li> <p>You can click and drag the translator on the manipulator to translate the plane along its normal.</p> <p></p> </li> <li> <p>You can click and drag the rotator to rotate the plane around the manipulator.</p> <p></p> <p>If you would like to change the center of rotation, you can press the shift key while clicking on the plane with the left mouse button to move the manipulator.</p> <p></p> </li> </ol>"},{"location":"tutorials/tutorials/","title":"Tutorials","text":""}]}